// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: command.proto

#ifndef PROTOBUF_INCLUDED_command_2eproto
#define PROTOBUF_INCLUDED_command_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_command_2eproto 

namespace protobuf_command_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[35];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
}  // namespace protobuf_command_2eproto
namespace dapi {
namespace commands {
class AttackMonster;
class AttackMonsterDefaultTypeInternal;
extern AttackMonsterDefaultTypeInternal _AttackMonster_default_instance_;
class AttackXY;
class AttackXYDefaultTypeInternal;
extern AttackXYDefaultTypeInternal _AttackXY_default_instance_;
class BuyItem;
class BuyItemDefaultTypeInternal;
extern BuyItemDefaultTypeInternal _BuyItem_default_instance_;
class CancelQText;
class CancelQTextDefaultTypeInternal;
extern CancelQTextDefaultTypeInternal _CancelQText_default_instance_;
class CastMonster;
class CastMonsterDefaultTypeInternal;
extern CastMonsterDefaultTypeInternal _CastMonster_default_instance_;
class CastXY;
class CastXYDefaultTypeInternal;
extern CastXYDefaultTypeInternal _CastXY_default_instance_;
class ClearCursor;
class ClearCursorDefaultTypeInternal;
extern ClearCursorDefaultTypeInternal _ClearCursor_default_instance_;
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class DisarmTrap;
class DisarmTrapDefaultTypeInternal;
extern DisarmTrapDefaultTypeInternal _DisarmTrap_default_instance_;
class DropCursorItem;
class DropCursorItemDefaultTypeInternal;
extern DropCursorItemDefaultTypeInternal _DropCursorItem_default_instance_;
class GetItem;
class GetItemDefaultTypeInternal;
extern GetItemDefaultTypeInternal _GetItem_default_instance_;
class IdentifyItem;
class IdentifyItemDefaultTypeInternal;
extern IdentifyItemDefaultTypeInternal _IdentifyItem_default_instance_;
class IdentifyStoreItem;
class IdentifyStoreItemDefaultTypeInternal;
extern IdentifyStoreItemDefaultTypeInternal _IdentifyStoreItem_default_instance_;
class IncreaseStat;
class IncreaseStatDefaultTypeInternal;
extern IncreaseStatDefaultTypeInternal _IncreaseStat_default_instance_;
class Move;
class MoveDefaultTypeInternal;
extern MoveDefaultTypeInternal _Move_default_instance_;
class OperateObject;
class OperateObjectDefaultTypeInternal;
extern OperateObjectDefaultTypeInternal _OperateObject_default_instance_;
class PutCursorItem;
class PutCursorItemDefaultTypeInternal;
extern PutCursorItemDefaultTypeInternal _PutCursorItem_default_instance_;
class PutInCursor;
class PutInCursorDefaultTypeInternal;
extern PutInCursorDefaultTypeInternal _PutInCursor_default_instance_;
class Quit;
class QuitDefaultTypeInternal;
extern QuitDefaultTypeInternal _Quit_default_instance_;
class RechargeItem;
class RechargeItemDefaultTypeInternal;
extern RechargeItemDefaultTypeInternal _RechargeItem_default_instance_;
class RepairItem;
class RepairItemDefaultTypeInternal;
extern RepairItemDefaultTypeInternal _RepairItem_default_instance_;
class SaveGame;
class SaveGameDefaultTypeInternal;
extern SaveGameDefaultTypeInternal _SaveGame_default_instance_;
class SelectStoreOption;
class SelectStoreOptionDefaultTypeInternal;
extern SelectStoreOptionDefaultTypeInternal _SelectStoreOption_default_instance_;
class SellItem;
class SellItemDefaultTypeInternal;
extern SellItemDefaultTypeInternal _SellItem_default_instance_;
class SendChat;
class SendChatDefaultTypeInternal;
extern SendChatDefaultTypeInternal _SendChat_default_instance_;
class SetFPS;
class SetFPSDefaultTypeInternal;
extern SetFPSDefaultTypeInternal _SetFPS_default_instance_;
class SetSpell;
class SetSpellDefaultTypeInternal;
extern SetSpellDefaultTypeInternal _SetSpell_default_instance_;
class SkillRecharge;
class SkillRechargeDefaultTypeInternal;
extern SkillRechargeDefaultTypeInternal _SkillRecharge_default_instance_;
class SkillRepair;
class SkillRepairDefaultTypeInternal;
extern SkillRepairDefaultTypeInternal _SkillRepair_default_instance_;
class Talk;
class TalkDefaultTypeInternal;
extern TalkDefaultTypeInternal _Talk_default_instance_;
class ToggleCharacterSheet;
class ToggleCharacterSheetDefaultTypeInternal;
extern ToggleCharacterSheetDefaultTypeInternal _ToggleCharacterSheet_default_instance_;
class ToggleInventory;
class ToggleInventoryDefaultTypeInternal;
extern ToggleInventoryDefaultTypeInternal _ToggleInventory_default_instance_;
class ToggleMenu;
class ToggleMenuDefaultTypeInternal;
extern ToggleMenuDefaultTypeInternal _ToggleMenu_default_instance_;
class UseBeltItem;
class UseBeltItemDefaultTypeInternal;
extern UseBeltItemDefaultTypeInternal _UseBeltItem_default_instance_;
class UseItem;
class UseItemDefaultTypeInternal;
extern UseItemDefaultTypeInternal _UseItem_default_instance_;
}  // namespace commands
}  // namespace dapi
namespace google {
namespace protobuf {
template<> ::dapi::commands::AttackMonster* Arena::CreateMaybeMessage<::dapi::commands::AttackMonster>(Arena*);
template<> ::dapi::commands::AttackXY* Arena::CreateMaybeMessage<::dapi::commands::AttackXY>(Arena*);
template<> ::dapi::commands::BuyItem* Arena::CreateMaybeMessage<::dapi::commands::BuyItem>(Arena*);
template<> ::dapi::commands::CancelQText* Arena::CreateMaybeMessage<::dapi::commands::CancelQText>(Arena*);
template<> ::dapi::commands::CastMonster* Arena::CreateMaybeMessage<::dapi::commands::CastMonster>(Arena*);
template<> ::dapi::commands::CastXY* Arena::CreateMaybeMessage<::dapi::commands::CastXY>(Arena*);
template<> ::dapi::commands::ClearCursor* Arena::CreateMaybeMessage<::dapi::commands::ClearCursor>(Arena*);
template<> ::dapi::commands::Command* Arena::CreateMaybeMessage<::dapi::commands::Command>(Arena*);
template<> ::dapi::commands::DisarmTrap* Arena::CreateMaybeMessage<::dapi::commands::DisarmTrap>(Arena*);
template<> ::dapi::commands::DropCursorItem* Arena::CreateMaybeMessage<::dapi::commands::DropCursorItem>(Arena*);
template<> ::dapi::commands::GetItem* Arena::CreateMaybeMessage<::dapi::commands::GetItem>(Arena*);
template<> ::dapi::commands::IdentifyItem* Arena::CreateMaybeMessage<::dapi::commands::IdentifyItem>(Arena*);
template<> ::dapi::commands::IdentifyStoreItem* Arena::CreateMaybeMessage<::dapi::commands::IdentifyStoreItem>(Arena*);
template<> ::dapi::commands::IncreaseStat* Arena::CreateMaybeMessage<::dapi::commands::IncreaseStat>(Arena*);
template<> ::dapi::commands::Move* Arena::CreateMaybeMessage<::dapi::commands::Move>(Arena*);
template<> ::dapi::commands::OperateObject* Arena::CreateMaybeMessage<::dapi::commands::OperateObject>(Arena*);
template<> ::dapi::commands::PutCursorItem* Arena::CreateMaybeMessage<::dapi::commands::PutCursorItem>(Arena*);
template<> ::dapi::commands::PutInCursor* Arena::CreateMaybeMessage<::dapi::commands::PutInCursor>(Arena*);
template<> ::dapi::commands::Quit* Arena::CreateMaybeMessage<::dapi::commands::Quit>(Arena*);
template<> ::dapi::commands::RechargeItem* Arena::CreateMaybeMessage<::dapi::commands::RechargeItem>(Arena*);
template<> ::dapi::commands::RepairItem* Arena::CreateMaybeMessage<::dapi::commands::RepairItem>(Arena*);
template<> ::dapi::commands::SaveGame* Arena::CreateMaybeMessage<::dapi::commands::SaveGame>(Arena*);
template<> ::dapi::commands::SelectStoreOption* Arena::CreateMaybeMessage<::dapi::commands::SelectStoreOption>(Arena*);
template<> ::dapi::commands::SellItem* Arena::CreateMaybeMessage<::dapi::commands::SellItem>(Arena*);
template<> ::dapi::commands::SendChat* Arena::CreateMaybeMessage<::dapi::commands::SendChat>(Arena*);
template<> ::dapi::commands::SetFPS* Arena::CreateMaybeMessage<::dapi::commands::SetFPS>(Arena*);
template<> ::dapi::commands::SetSpell* Arena::CreateMaybeMessage<::dapi::commands::SetSpell>(Arena*);
template<> ::dapi::commands::SkillRecharge* Arena::CreateMaybeMessage<::dapi::commands::SkillRecharge>(Arena*);
template<> ::dapi::commands::SkillRepair* Arena::CreateMaybeMessage<::dapi::commands::SkillRepair>(Arena*);
template<> ::dapi::commands::Talk* Arena::CreateMaybeMessage<::dapi::commands::Talk>(Arena*);
template<> ::dapi::commands::ToggleCharacterSheet* Arena::CreateMaybeMessage<::dapi::commands::ToggleCharacterSheet>(Arena*);
template<> ::dapi::commands::ToggleInventory* Arena::CreateMaybeMessage<::dapi::commands::ToggleInventory>(Arena*);
template<> ::dapi::commands::ToggleMenu* Arena::CreateMaybeMessage<::dapi::commands::ToggleMenu>(Arena*);
template<> ::dapi::commands::UseBeltItem* Arena::CreateMaybeMessage<::dapi::commands::UseBeltItem>(Arena*);
template<> ::dapi::commands::UseItem* Arena::CreateMaybeMessage<::dapi::commands::UseItem>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace dapi {
namespace commands {

// ===================================================================

class SetFPS : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.SetFPS) */ {
 public:
  SetFPS();
  virtual ~SetFPS();

  SetFPS(const SetFPS& from);

  inline SetFPS& operator=(const SetFPS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetFPS(SetFPS&& from) noexcept
    : SetFPS() {
    *this = ::std::move(from);
  }

  inline SetFPS& operator=(SetFPS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SetFPS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetFPS* internal_default_instance() {
    return reinterpret_cast<const SetFPS*>(
               &_SetFPS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SetFPS* other);
  friend void swap(SetFPS& a, SetFPS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetFPS* New() const final {
    return CreateMaybeMessage<SetFPS>(NULL);
  }

  SetFPS* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetFPS>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SetFPS& from);
  void MergeFrom(const SetFPS& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetFPS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 FPS = 1;
  void clear_fps();
  static const int kFPSFieldNumber = 1;
  ::google::protobuf::uint32 fps() const;
  void set_fps(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.SetFPS)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 fps_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CancelQText : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.CancelQText) */ {
 public:
  CancelQText();
  virtual ~CancelQText();

  CancelQText(const CancelQText& from);

  inline CancelQText& operator=(const CancelQText& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CancelQText(CancelQText&& from) noexcept
    : CancelQText() {
    *this = ::std::move(from);
  }

  inline CancelQText& operator=(CancelQText&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const CancelQText& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CancelQText* internal_default_instance() {
    return reinterpret_cast<const CancelQText*>(
               &_CancelQText_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(CancelQText* other);
  friend void swap(CancelQText& a, CancelQText& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CancelQText* New() const final {
    return CreateMaybeMessage<CancelQText>(NULL);
  }

  CancelQText* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CancelQText>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const CancelQText& from);
  void MergeFrom(const CancelQText& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CancelQText* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dapi.commands.CancelQText)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Move : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.Move) */ {
 public:
  Move();
  virtual ~Move();

  Move(const Move& from);

  inline Move& operator=(const Move& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Move(Move&& from) noexcept
    : Move() {
    *this = ::std::move(from);
  }

  inline Move& operator=(Move&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Move& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Move* internal_default_instance() {
    return reinterpret_cast<const Move*>(
               &_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Move* other);
  friend void swap(Move& a, Move& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Move* New() const final {
    return CreateMaybeMessage<Move>(NULL);
  }

  Move* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Move>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Move& from);
  void MergeFrom(const Move& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Move* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // uint32 targetX = 2;
  void clear_targetx();
  static const int kTargetXFieldNumber = 2;
  ::google::protobuf::uint32 targetx() const;
  void set_targetx(::google::protobuf::uint32 value);

  // uint32 targetY = 3;
  void clear_targety();
  static const int kTargetYFieldNumber = 3;
  ::google::protobuf::uint32 targety() const;
  void set_targety(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.Move)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 targetx_;
  ::google::protobuf::uint32 targety_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Talk : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.Talk) */ {
 public:
  Talk();
  virtual ~Talk();

  Talk(const Talk& from);

  inline Talk& operator=(const Talk& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Talk(Talk&& from) noexcept
    : Talk() {
    *this = ::std::move(from);
  }

  inline Talk& operator=(Talk&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Talk& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Talk* internal_default_instance() {
    return reinterpret_cast<const Talk*>(
               &_Talk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Talk* other);
  friend void swap(Talk& a, Talk& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Talk* New() const final {
    return CreateMaybeMessage<Talk>(NULL);
  }

  Talk* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Talk>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Talk& from);
  void MergeFrom(const Talk& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Talk* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 targetX = 1;
  void clear_targetx();
  static const int kTargetXFieldNumber = 1;
  ::google::protobuf::uint32 targetx() const;
  void set_targetx(::google::protobuf::uint32 value);

  // uint32 targetY = 2;
  void clear_targety();
  static const int kTargetYFieldNumber = 2;
  ::google::protobuf::uint32 targety() const;
  void set_targety(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.Talk)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 targetx_;
  ::google::protobuf::uint32 targety_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SelectStoreOption : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.SelectStoreOption) */ {
 public:
  SelectStoreOption();
  virtual ~SelectStoreOption();

  SelectStoreOption(const SelectStoreOption& from);

  inline SelectStoreOption& operator=(const SelectStoreOption& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SelectStoreOption(SelectStoreOption&& from) noexcept
    : SelectStoreOption() {
    *this = ::std::move(from);
  }

  inline SelectStoreOption& operator=(SelectStoreOption&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SelectStoreOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SelectStoreOption* internal_default_instance() {
    return reinterpret_cast<const SelectStoreOption*>(
               &_SelectStoreOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SelectStoreOption* other);
  friend void swap(SelectStoreOption& a, SelectStoreOption& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SelectStoreOption* New() const final {
    return CreateMaybeMessage<SelectStoreOption>(NULL);
  }

  SelectStoreOption* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SelectStoreOption>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SelectStoreOption& from);
  void MergeFrom(const SelectStoreOption& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SelectStoreOption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 option = 1;
  void clear_option();
  static const int kOptionFieldNumber = 1;
  ::google::protobuf::uint32 option() const;
  void set_option(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.SelectStoreOption)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 option_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BuyItem : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.BuyItem) */ {
 public:
  BuyItem();
  virtual ~BuyItem();

  BuyItem(const BuyItem& from);

  inline BuyItem& operator=(const BuyItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BuyItem(BuyItem&& from) noexcept
    : BuyItem() {
    *this = ::std::move(from);
  }

  inline BuyItem& operator=(BuyItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const BuyItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuyItem* internal_default_instance() {
    return reinterpret_cast<const BuyItem*>(
               &_BuyItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(BuyItem* other);
  friend void swap(BuyItem& a, BuyItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BuyItem* New() const final {
    return CreateMaybeMessage<BuyItem>(NULL);
  }

  BuyItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BuyItem>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const BuyItem& from);
  void MergeFrom(const BuyItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BuyItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 ID = 1;
  void clear_id();
  static const int kIDFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.BuyItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SellItem : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.SellItem) */ {
 public:
  SellItem();
  virtual ~SellItem();

  SellItem(const SellItem& from);

  inline SellItem& operator=(const SellItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SellItem(SellItem&& from) noexcept
    : SellItem() {
    *this = ::std::move(from);
  }

  inline SellItem& operator=(SellItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SellItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SellItem* internal_default_instance() {
    return reinterpret_cast<const SellItem*>(
               &_SellItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(SellItem* other);
  friend void swap(SellItem& a, SellItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SellItem* New() const final {
    return CreateMaybeMessage<SellItem>(NULL);
  }

  SellItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SellItem>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SellItem& from);
  void MergeFrom(const SellItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SellItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 ID = 1;
  void clear_id();
  static const int kIDFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.SellItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RechargeItem : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.RechargeItem) */ {
 public:
  RechargeItem();
  virtual ~RechargeItem();

  RechargeItem(const RechargeItem& from);

  inline RechargeItem& operator=(const RechargeItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RechargeItem(RechargeItem&& from) noexcept
    : RechargeItem() {
    *this = ::std::move(from);
  }

  inline RechargeItem& operator=(RechargeItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RechargeItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RechargeItem* internal_default_instance() {
    return reinterpret_cast<const RechargeItem*>(
               &_RechargeItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(RechargeItem* other);
  friend void swap(RechargeItem& a, RechargeItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RechargeItem* New() const final {
    return CreateMaybeMessage<RechargeItem>(NULL);
  }

  RechargeItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RechargeItem>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RechargeItem& from);
  void MergeFrom(const RechargeItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RechargeItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 ID = 1;
  void clear_id();
  static const int kIDFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.RechargeItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RepairItem : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.RepairItem) */ {
 public:
  RepairItem();
  virtual ~RepairItem();

  RepairItem(const RepairItem& from);

  inline RepairItem& operator=(const RepairItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RepairItem(RepairItem&& from) noexcept
    : RepairItem() {
    *this = ::std::move(from);
  }

  inline RepairItem& operator=(RepairItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RepairItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RepairItem* internal_default_instance() {
    return reinterpret_cast<const RepairItem*>(
               &_RepairItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(RepairItem* other);
  friend void swap(RepairItem& a, RepairItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RepairItem* New() const final {
    return CreateMaybeMessage<RepairItem>(NULL);
  }

  RepairItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RepairItem>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RepairItem& from);
  void MergeFrom(const RepairItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RepairItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 ID = 1;
  void clear_id();
  static const int kIDFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.RepairItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AttackMonster : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.AttackMonster) */ {
 public:
  AttackMonster();
  virtual ~AttackMonster();

  AttackMonster(const AttackMonster& from);

  inline AttackMonster& operator=(const AttackMonster& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AttackMonster(AttackMonster&& from) noexcept
    : AttackMonster() {
    *this = ::std::move(from);
  }

  inline AttackMonster& operator=(AttackMonster&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AttackMonster& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AttackMonster* internal_default_instance() {
    return reinterpret_cast<const AttackMonster*>(
               &_AttackMonster_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(AttackMonster* other);
  friend void swap(AttackMonster& a, AttackMonster& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AttackMonster* New() const final {
    return CreateMaybeMessage<AttackMonster>(NULL);
  }

  AttackMonster* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AttackMonster>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AttackMonster& from);
  void MergeFrom(const AttackMonster& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AttackMonster* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.AttackMonster)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AttackXY : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.AttackXY) */ {
 public:
  AttackXY();
  virtual ~AttackXY();

  AttackXY(const AttackXY& from);

  inline AttackXY& operator=(const AttackXY& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AttackXY(AttackXY&& from) noexcept
    : AttackXY() {
    *this = ::std::move(from);
  }

  inline AttackXY& operator=(AttackXY&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AttackXY& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AttackXY* internal_default_instance() {
    return reinterpret_cast<const AttackXY*>(
               &_AttackXY_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(AttackXY* other);
  friend void swap(AttackXY& a, AttackXY& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AttackXY* New() const final {
    return CreateMaybeMessage<AttackXY>(NULL);
  }

  AttackXY* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AttackXY>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AttackXY& from);
  void MergeFrom(const AttackXY& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AttackXY* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // sint32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // sint32 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.AttackXY)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperateObject : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.OperateObject) */ {
 public:
  OperateObject();
  virtual ~OperateObject();

  OperateObject(const OperateObject& from);

  inline OperateObject& operator=(const OperateObject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperateObject(OperateObject&& from) noexcept
    : OperateObject() {
    *this = ::std::move(from);
  }

  inline OperateObject& operator=(OperateObject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const OperateObject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperateObject* internal_default_instance() {
    return reinterpret_cast<const OperateObject*>(
               &_OperateObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(OperateObject* other);
  friend void swap(OperateObject& a, OperateObject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperateObject* New() const final {
    return CreateMaybeMessage<OperateObject>(NULL);
  }

  OperateObject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OperateObject>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const OperateObject& from);
  void MergeFrom(const OperateObject& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OperateObject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.OperateObject)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UseBeltItem : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.UseBeltItem) */ {
 public:
  UseBeltItem();
  virtual ~UseBeltItem();

  UseBeltItem(const UseBeltItem& from);

  inline UseBeltItem& operator=(const UseBeltItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UseBeltItem(UseBeltItem&& from) noexcept
    : UseBeltItem() {
    *this = ::std::move(from);
  }

  inline UseBeltItem& operator=(UseBeltItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const UseBeltItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UseBeltItem* internal_default_instance() {
    return reinterpret_cast<const UseBeltItem*>(
               &_UseBeltItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(UseBeltItem* other);
  friend void swap(UseBeltItem& a, UseBeltItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UseBeltItem* New() const final {
    return CreateMaybeMessage<UseBeltItem>(NULL);
  }

  UseBeltItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UseBeltItem>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const UseBeltItem& from);
  void MergeFrom(const UseBeltItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UseBeltItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 slot = 1;
  void clear_slot();
  static const int kSlotFieldNumber = 1;
  ::google::protobuf::uint32 slot() const;
  void set_slot(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.UseBeltItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 slot_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ToggleCharacterSheet : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.ToggleCharacterSheet) */ {
 public:
  ToggleCharacterSheet();
  virtual ~ToggleCharacterSheet();

  ToggleCharacterSheet(const ToggleCharacterSheet& from);

  inline ToggleCharacterSheet& operator=(const ToggleCharacterSheet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ToggleCharacterSheet(ToggleCharacterSheet&& from) noexcept
    : ToggleCharacterSheet() {
    *this = ::std::move(from);
  }

  inline ToggleCharacterSheet& operator=(ToggleCharacterSheet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ToggleCharacterSheet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ToggleCharacterSheet* internal_default_instance() {
    return reinterpret_cast<const ToggleCharacterSheet*>(
               &_ToggleCharacterSheet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ToggleCharacterSheet* other);
  friend void swap(ToggleCharacterSheet& a, ToggleCharacterSheet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ToggleCharacterSheet* New() const final {
    return CreateMaybeMessage<ToggleCharacterSheet>(NULL);
  }

  ToggleCharacterSheet* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ToggleCharacterSheet>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ToggleCharacterSheet& from);
  void MergeFrom(const ToggleCharacterSheet& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ToggleCharacterSheet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dapi.commands.ToggleCharacterSheet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IncreaseStat : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.IncreaseStat) */ {
 public:
  IncreaseStat();
  virtual ~IncreaseStat();

  IncreaseStat(const IncreaseStat& from);

  inline IncreaseStat& operator=(const IncreaseStat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IncreaseStat(IncreaseStat&& from) noexcept
    : IncreaseStat() {
    *this = ::std::move(from);
  }

  inline IncreaseStat& operator=(IncreaseStat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const IncreaseStat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IncreaseStat* internal_default_instance() {
    return reinterpret_cast<const IncreaseStat*>(
               &_IncreaseStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(IncreaseStat* other);
  friend void swap(IncreaseStat& a, IncreaseStat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IncreaseStat* New() const final {
    return CreateMaybeMessage<IncreaseStat>(NULL);
  }

  IncreaseStat* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IncreaseStat>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const IncreaseStat& from);
  void MergeFrom(const IncreaseStat& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IncreaseStat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 stat = 1;
  void clear_stat();
  static const int kStatFieldNumber = 1;
  ::google::protobuf::uint32 stat() const;
  void set_stat(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.IncreaseStat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 stat_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetItem : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.GetItem) */ {
 public:
  GetItem();
  virtual ~GetItem();

  GetItem(const GetItem& from);

  inline GetItem& operator=(const GetItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetItem(GetItem&& from) noexcept
    : GetItem() {
    *this = ::std::move(from);
  }

  inline GetItem& operator=(GetItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const GetItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetItem* internal_default_instance() {
    return reinterpret_cast<const GetItem*>(
               &_GetItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(GetItem* other);
  friend void swap(GetItem& a, GetItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetItem* New() const final {
    return CreateMaybeMessage<GetItem>(NULL);
  }

  GetItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetItem>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GetItem& from);
  void MergeFrom(const GetItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 ID = 1;
  void clear_id();
  static const int kIDFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.GetItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetSpell : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.SetSpell) */ {
 public:
  SetSpell();
  virtual ~SetSpell();

  SetSpell(const SetSpell& from);

  inline SetSpell& operator=(const SetSpell& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetSpell(SetSpell&& from) noexcept
    : SetSpell() {
    *this = ::std::move(from);
  }

  inline SetSpell& operator=(SetSpell&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SetSpell& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetSpell* internal_default_instance() {
    return reinterpret_cast<const SetSpell*>(
               &_SetSpell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(SetSpell* other);
  friend void swap(SetSpell& a, SetSpell& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetSpell* New() const final {
    return CreateMaybeMessage<SetSpell>(NULL);
  }

  SetSpell* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetSpell>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SetSpell& from);
  void MergeFrom(const SetSpell& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetSpell* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // sint32 spellID = 1;
  void clear_spellid();
  static const int kSpellIDFieldNumber = 1;
  ::google::protobuf::int32 spellid() const;
  void set_spellid(::google::protobuf::int32 value);

  // sint32 spellType = 2;
  void clear_spelltype();
  static const int kSpellTypeFieldNumber = 2;
  ::google::protobuf::int32 spelltype() const;
  void set_spelltype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.SetSpell)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int32 spellid_;
  ::google::protobuf::int32 spelltype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CastMonster : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.CastMonster) */ {
 public:
  CastMonster();
  virtual ~CastMonster();

  CastMonster(const CastMonster& from);

  inline CastMonster& operator=(const CastMonster& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CastMonster(CastMonster&& from) noexcept
    : CastMonster() {
    *this = ::std::move(from);
  }

  inline CastMonster& operator=(CastMonster&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const CastMonster& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CastMonster* internal_default_instance() {
    return reinterpret_cast<const CastMonster*>(
               &_CastMonster_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(CastMonster* other);
  friend void swap(CastMonster& a, CastMonster& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CastMonster* New() const final {
    return CreateMaybeMessage<CastMonster>(NULL);
  }

  CastMonster* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CastMonster>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const CastMonster& from);
  void MergeFrom(const CastMonster& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CastMonster* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.CastMonster)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CastXY : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.CastXY) */ {
 public:
  CastXY();
  virtual ~CastXY();

  CastXY(const CastXY& from);

  inline CastXY& operator=(const CastXY& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CastXY(CastXY&& from) noexcept
    : CastXY() {
    *this = ::std::move(from);
  }

  inline CastXY& operator=(CastXY&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const CastXY& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CastXY* internal_default_instance() {
    return reinterpret_cast<const CastXY*>(
               &_CastXY_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(CastXY* other);
  friend void swap(CastXY& a, CastXY& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CastXY* New() const final {
    return CreateMaybeMessage<CastXY>(NULL);
  }

  CastXY* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CastXY>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const CastXY& from);
  void MergeFrom(const CastXY& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CastXY* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // sint32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // sint32 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.CastXY)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ToggleInventory : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.ToggleInventory) */ {
 public:
  ToggleInventory();
  virtual ~ToggleInventory();

  ToggleInventory(const ToggleInventory& from);

  inline ToggleInventory& operator=(const ToggleInventory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ToggleInventory(ToggleInventory&& from) noexcept
    : ToggleInventory() {
    *this = ::std::move(from);
  }

  inline ToggleInventory& operator=(ToggleInventory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ToggleInventory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ToggleInventory* internal_default_instance() {
    return reinterpret_cast<const ToggleInventory*>(
               &_ToggleInventory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ToggleInventory* other);
  friend void swap(ToggleInventory& a, ToggleInventory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ToggleInventory* New() const final {
    return CreateMaybeMessage<ToggleInventory>(NULL);
  }

  ToggleInventory* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ToggleInventory>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ToggleInventory& from);
  void MergeFrom(const ToggleInventory& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ToggleInventory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dapi.commands.ToggleInventory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PutInCursor : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.PutInCursor) */ {
 public:
  PutInCursor();
  virtual ~PutInCursor();

  PutInCursor(const PutInCursor& from);

  inline PutInCursor& operator=(const PutInCursor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PutInCursor(PutInCursor&& from) noexcept
    : PutInCursor() {
    *this = ::std::move(from);
  }

  inline PutInCursor& operator=(PutInCursor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PutInCursor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PutInCursor* internal_default_instance() {
    return reinterpret_cast<const PutInCursor*>(
               &_PutInCursor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(PutInCursor* other);
  friend void swap(PutInCursor& a, PutInCursor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PutInCursor* New() const final {
    return CreateMaybeMessage<PutInCursor>(NULL);
  }

  PutInCursor* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PutInCursor>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PutInCursor& from);
  void MergeFrom(const PutInCursor& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PutInCursor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 ID = 1;
  void clear_id();
  static const int kIDFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.PutInCursor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PutCursorItem : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.PutCursorItem) */ {
 public:
  PutCursorItem();
  virtual ~PutCursorItem();

  PutCursorItem(const PutCursorItem& from);

  inline PutCursorItem& operator=(const PutCursorItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PutCursorItem(PutCursorItem&& from) noexcept
    : PutCursorItem() {
    *this = ::std::move(from);
  }

  inline PutCursorItem& operator=(PutCursorItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PutCursorItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PutCursorItem* internal_default_instance() {
    return reinterpret_cast<const PutCursorItem*>(
               &_PutCursorItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(PutCursorItem* other);
  friend void swap(PutCursorItem& a, PutCursorItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PutCursorItem* New() const final {
    return CreateMaybeMessage<PutCursorItem>(NULL);
  }

  PutCursorItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PutCursorItem>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PutCursorItem& from);
  void MergeFrom(const PutCursorItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PutCursorItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // sint32 target = 1;
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::int32 target() const;
  void set_target(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.PutCursorItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int32 target_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DropCursorItem : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.DropCursorItem) */ {
 public:
  DropCursorItem();
  virtual ~DropCursorItem();

  DropCursorItem(const DropCursorItem& from);

  inline DropCursorItem& operator=(const DropCursorItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DropCursorItem(DropCursorItem&& from) noexcept
    : DropCursorItem() {
    *this = ::std::move(from);
  }

  inline DropCursorItem& operator=(DropCursorItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DropCursorItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DropCursorItem* internal_default_instance() {
    return reinterpret_cast<const DropCursorItem*>(
               &_DropCursorItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(DropCursorItem* other);
  friend void swap(DropCursorItem& a, DropCursorItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DropCursorItem* New() const final {
    return CreateMaybeMessage<DropCursorItem>(NULL);
  }

  DropCursorItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DropCursorItem>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DropCursorItem& from);
  void MergeFrom(const DropCursorItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DropCursorItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dapi.commands.DropCursorItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UseItem : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.UseItem) */ {
 public:
  UseItem();
  virtual ~UseItem();

  UseItem(const UseItem& from);

  inline UseItem& operator=(const UseItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UseItem(UseItem&& from) noexcept
    : UseItem() {
    *this = ::std::move(from);
  }

  inline UseItem& operator=(UseItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const UseItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UseItem* internal_default_instance() {
    return reinterpret_cast<const UseItem*>(
               &_UseItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(UseItem* other);
  friend void swap(UseItem& a, UseItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UseItem* New() const final {
    return CreateMaybeMessage<UseItem>(NULL);
  }

  UseItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UseItem>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const UseItem& from);
  void MergeFrom(const UseItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UseItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 ID = 1;
  void clear_id();
  static const int kIDFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.UseItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IdentifyStoreItem : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.IdentifyStoreItem) */ {
 public:
  IdentifyStoreItem();
  virtual ~IdentifyStoreItem();

  IdentifyStoreItem(const IdentifyStoreItem& from);

  inline IdentifyStoreItem& operator=(const IdentifyStoreItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IdentifyStoreItem(IdentifyStoreItem&& from) noexcept
    : IdentifyStoreItem() {
    *this = ::std::move(from);
  }

  inline IdentifyStoreItem& operator=(IdentifyStoreItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const IdentifyStoreItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IdentifyStoreItem* internal_default_instance() {
    return reinterpret_cast<const IdentifyStoreItem*>(
               &_IdentifyStoreItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(IdentifyStoreItem* other);
  friend void swap(IdentifyStoreItem& a, IdentifyStoreItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IdentifyStoreItem* New() const final {
    return CreateMaybeMessage<IdentifyStoreItem>(NULL);
  }

  IdentifyStoreItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IdentifyStoreItem>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const IdentifyStoreItem& from);
  void MergeFrom(const IdentifyStoreItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IdentifyStoreItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 ID = 1;
  void clear_id();
  static const int kIDFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.IdentifyStoreItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DisarmTrap : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.DisarmTrap) */ {
 public:
  DisarmTrap();
  virtual ~DisarmTrap();

  DisarmTrap(const DisarmTrap& from);

  inline DisarmTrap& operator=(const DisarmTrap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DisarmTrap(DisarmTrap&& from) noexcept
    : DisarmTrap() {
    *this = ::std::move(from);
  }

  inline DisarmTrap& operator=(DisarmTrap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DisarmTrap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DisarmTrap* internal_default_instance() {
    return reinterpret_cast<const DisarmTrap*>(
               &_DisarmTrap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(DisarmTrap* other);
  friend void swap(DisarmTrap& a, DisarmTrap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DisarmTrap* New() const final {
    return CreateMaybeMessage<DisarmTrap>(NULL);
  }

  DisarmTrap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DisarmTrap>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DisarmTrap& from);
  void MergeFrom(const DisarmTrap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DisarmTrap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.DisarmTrap)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SkillRepair : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.SkillRepair) */ {
 public:
  SkillRepair();
  virtual ~SkillRepair();

  SkillRepair(const SkillRepair& from);

  inline SkillRepair& operator=(const SkillRepair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SkillRepair(SkillRepair&& from) noexcept
    : SkillRepair() {
    *this = ::std::move(from);
  }

  inline SkillRepair& operator=(SkillRepair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SkillRepair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SkillRepair* internal_default_instance() {
    return reinterpret_cast<const SkillRepair*>(
               &_SkillRepair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(SkillRepair* other);
  friend void swap(SkillRepair& a, SkillRepair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SkillRepair* New() const final {
    return CreateMaybeMessage<SkillRepair>(NULL);
  }

  SkillRepair* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SkillRepair>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SkillRepair& from);
  void MergeFrom(const SkillRepair& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SkillRepair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 ID = 1;
  void clear_id();
  static const int kIDFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.SkillRepair)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SkillRecharge : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.SkillRecharge) */ {
 public:
  SkillRecharge();
  virtual ~SkillRecharge();

  SkillRecharge(const SkillRecharge& from);

  inline SkillRecharge& operator=(const SkillRecharge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SkillRecharge(SkillRecharge&& from) noexcept
    : SkillRecharge() {
    *this = ::std::move(from);
  }

  inline SkillRecharge& operator=(SkillRecharge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SkillRecharge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SkillRecharge* internal_default_instance() {
    return reinterpret_cast<const SkillRecharge*>(
               &_SkillRecharge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(SkillRecharge* other);
  friend void swap(SkillRecharge& a, SkillRecharge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SkillRecharge* New() const final {
    return CreateMaybeMessage<SkillRecharge>(NULL);
  }

  SkillRecharge* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SkillRecharge>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SkillRecharge& from);
  void MergeFrom(const SkillRecharge& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SkillRecharge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 ID = 1;
  void clear_id();
  static const int kIDFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.SkillRecharge)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ToggleMenu : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.ToggleMenu) */ {
 public:
  ToggleMenu();
  virtual ~ToggleMenu();

  ToggleMenu(const ToggleMenu& from);

  inline ToggleMenu& operator=(const ToggleMenu& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ToggleMenu(ToggleMenu&& from) noexcept
    : ToggleMenu() {
    *this = ::std::move(from);
  }

  inline ToggleMenu& operator=(ToggleMenu&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ToggleMenu& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ToggleMenu* internal_default_instance() {
    return reinterpret_cast<const ToggleMenu*>(
               &_ToggleMenu_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(ToggleMenu* other);
  friend void swap(ToggleMenu& a, ToggleMenu& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ToggleMenu* New() const final {
    return CreateMaybeMessage<ToggleMenu>(NULL);
  }

  ToggleMenu* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ToggleMenu>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ToggleMenu& from);
  void MergeFrom(const ToggleMenu& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ToggleMenu* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dapi.commands.ToggleMenu)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SaveGame : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.SaveGame) */ {
 public:
  SaveGame();
  virtual ~SaveGame();

  SaveGame(const SaveGame& from);

  inline SaveGame& operator=(const SaveGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SaveGame(SaveGame&& from) noexcept
    : SaveGame() {
    *this = ::std::move(from);
  }

  inline SaveGame& operator=(SaveGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SaveGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SaveGame* internal_default_instance() {
    return reinterpret_cast<const SaveGame*>(
               &_SaveGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(SaveGame* other);
  friend void swap(SaveGame& a, SaveGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SaveGame* New() const final {
    return CreateMaybeMessage<SaveGame>(NULL);
  }

  SaveGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SaveGame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SaveGame& from);
  void MergeFrom(const SaveGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SaveGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dapi.commands.SaveGame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Quit : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.Quit) */ {
 public:
  Quit();
  virtual ~Quit();

  Quit(const Quit& from);

  inline Quit& operator=(const Quit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Quit(Quit&& from) noexcept
    : Quit() {
    *this = ::std::move(from);
  }

  inline Quit& operator=(Quit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Quit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quit* internal_default_instance() {
    return reinterpret_cast<const Quit*>(
               &_Quit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(Quit* other);
  friend void swap(Quit& a, Quit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Quit* New() const final {
    return CreateMaybeMessage<Quit>(NULL);
  }

  Quit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Quit>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Quit& from);
  void MergeFrom(const Quit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Quit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dapi.commands.Quit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClearCursor : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.ClearCursor) */ {
 public:
  ClearCursor();
  virtual ~ClearCursor();

  ClearCursor(const ClearCursor& from);

  inline ClearCursor& operator=(const ClearCursor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClearCursor(ClearCursor&& from) noexcept
    : ClearCursor() {
    *this = ::std::move(from);
  }

  inline ClearCursor& operator=(ClearCursor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ClearCursor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClearCursor* internal_default_instance() {
    return reinterpret_cast<const ClearCursor*>(
               &_ClearCursor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(ClearCursor* other);
  friend void swap(ClearCursor& a, ClearCursor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClearCursor* New() const final {
    return CreateMaybeMessage<ClearCursor>(NULL);
  }

  ClearCursor* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClearCursor>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ClearCursor& from);
  void MergeFrom(const ClearCursor& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClearCursor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dapi.commands.ClearCursor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IdentifyItem : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.IdentifyItem) */ {
 public:
  IdentifyItem();
  virtual ~IdentifyItem();

  IdentifyItem(const IdentifyItem& from);

  inline IdentifyItem& operator=(const IdentifyItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IdentifyItem(IdentifyItem&& from) noexcept
    : IdentifyItem() {
    *this = ::std::move(from);
  }

  inline IdentifyItem& operator=(IdentifyItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const IdentifyItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IdentifyItem* internal_default_instance() {
    return reinterpret_cast<const IdentifyItem*>(
               &_IdentifyItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(IdentifyItem* other);
  friend void swap(IdentifyItem& a, IdentifyItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IdentifyItem* New() const final {
    return CreateMaybeMessage<IdentifyItem>(NULL);
  }

  IdentifyItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IdentifyItem>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const IdentifyItem& from);
  void MergeFrom(const IdentifyItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IdentifyItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 ID = 1;
  void clear_id();
  static const int kIDFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dapi.commands.IdentifyItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SendChat : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.SendChat) */ {
 public:
  SendChat();
  virtual ~SendChat();

  SendChat(const SendChat& from);

  inline SendChat& operator=(const SendChat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SendChat(SendChat&& from) noexcept
    : SendChat() {
    *this = ::std::move(from);
  }

  inline SendChat& operator=(SendChat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SendChat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SendChat* internal_default_instance() {
    return reinterpret_cast<const SendChat*>(
               &_SendChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(SendChat* other);
  friend void swap(SendChat& a, SendChat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SendChat* New() const final {
    return CreateMaybeMessage<SendChat>(NULL);
  }

  SendChat* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SendChat>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SendChat& from);
  void MergeFrom(const SendChat& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SendChat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:dapi.commands.SendChat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_command_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:dapi.commands.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Command& default_instance();

  enum CommandCase {
    kMove = 1,
    kTalk = 2,
    kOption = 3,
    kBuyItem = 4,
    kSellItem = 5,
    kRechargeItem = 6,
    kRepairItem = 7,
    kAttackMonster = 8,
    kAttackXY = 9,
    kOperateObject = 10,
    kUseBeltItem = 11,
    kToggleCharacterSheet = 12,
    kIncreaseStat = 13,
    kGetItem = 14,
    kSetSpell = 15,
    kCastMonster = 16,
    kCastXY = 17,
    kToggleInventory = 18,
    kPutInCursor = 19,
    kPutCursorItem = 20,
    kDropCursorItem = 21,
    kUseItem = 22,
    kIdentifyStoreItem = 23,
    kCancelQText = 24,
    kSetFPS = 25,
    kDisarmTrap = 26,
    kSkillRepair = 27,
    kSkillRecharge = 28,
    kToggleMenu = 29,
    kSaveGame = 30,
    kQuit = 31,
    kClearCursor = 32,
    kIdentifyItem = 33,
    kSendChat = 34,
    COMMAND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(Command* other);
  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return CreateMaybeMessage<Command>(NULL);
  }

  Command* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .dapi.commands.Move move = 1;
  bool has_move() const;
  void clear_move();
  static const int kMoveFieldNumber = 1;
  private:
  const ::dapi::commands::Move& _internal_move() const;
  public:
  const ::dapi::commands::Move& move() const;
  ::dapi::commands::Move* release_move();
  ::dapi::commands::Move* mutable_move();
  void set_allocated_move(::dapi::commands::Move* move);

  // .dapi.commands.Talk talk = 2;
  bool has_talk() const;
  void clear_talk();
  static const int kTalkFieldNumber = 2;
  private:
  const ::dapi::commands::Talk& _internal_talk() const;
  public:
  const ::dapi::commands::Talk& talk() const;
  ::dapi::commands::Talk* release_talk();
  ::dapi::commands::Talk* mutable_talk();
  void set_allocated_talk(::dapi::commands::Talk* talk);

  // .dapi.commands.SelectStoreOption option = 3;
  bool has_option() const;
  void clear_option();
  static const int kOptionFieldNumber = 3;
  private:
  const ::dapi::commands::SelectStoreOption& _internal_option() const;
  public:
  const ::dapi::commands::SelectStoreOption& option() const;
  ::dapi::commands::SelectStoreOption* release_option();
  ::dapi::commands::SelectStoreOption* mutable_option();
  void set_allocated_option(::dapi::commands::SelectStoreOption* option);

  // .dapi.commands.BuyItem buyItem = 4;
  bool has_buyitem() const;
  void clear_buyitem();
  static const int kBuyItemFieldNumber = 4;
  private:
  const ::dapi::commands::BuyItem& _internal_buyitem() const;
  public:
  const ::dapi::commands::BuyItem& buyitem() const;
  ::dapi::commands::BuyItem* release_buyitem();
  ::dapi::commands::BuyItem* mutable_buyitem();
  void set_allocated_buyitem(::dapi::commands::BuyItem* buyitem);

  // .dapi.commands.SellItem sellItem = 5;
  bool has_sellitem() const;
  void clear_sellitem();
  static const int kSellItemFieldNumber = 5;
  private:
  const ::dapi::commands::SellItem& _internal_sellitem() const;
  public:
  const ::dapi::commands::SellItem& sellitem() const;
  ::dapi::commands::SellItem* release_sellitem();
  ::dapi::commands::SellItem* mutable_sellitem();
  void set_allocated_sellitem(::dapi::commands::SellItem* sellitem);

  // .dapi.commands.RechargeItem rechargeItem = 6;
  bool has_rechargeitem() const;
  void clear_rechargeitem();
  static const int kRechargeItemFieldNumber = 6;
  private:
  const ::dapi::commands::RechargeItem& _internal_rechargeitem() const;
  public:
  const ::dapi::commands::RechargeItem& rechargeitem() const;
  ::dapi::commands::RechargeItem* release_rechargeitem();
  ::dapi::commands::RechargeItem* mutable_rechargeitem();
  void set_allocated_rechargeitem(::dapi::commands::RechargeItem* rechargeitem);

  // .dapi.commands.RepairItem repairItem = 7;
  bool has_repairitem() const;
  void clear_repairitem();
  static const int kRepairItemFieldNumber = 7;
  private:
  const ::dapi::commands::RepairItem& _internal_repairitem() const;
  public:
  const ::dapi::commands::RepairItem& repairitem() const;
  ::dapi::commands::RepairItem* release_repairitem();
  ::dapi::commands::RepairItem* mutable_repairitem();
  void set_allocated_repairitem(::dapi::commands::RepairItem* repairitem);

  // .dapi.commands.AttackMonster attackMonster = 8;
  bool has_attackmonster() const;
  void clear_attackmonster();
  static const int kAttackMonsterFieldNumber = 8;
  private:
  const ::dapi::commands::AttackMonster& _internal_attackmonster() const;
  public:
  const ::dapi::commands::AttackMonster& attackmonster() const;
  ::dapi::commands::AttackMonster* release_attackmonster();
  ::dapi::commands::AttackMonster* mutable_attackmonster();
  void set_allocated_attackmonster(::dapi::commands::AttackMonster* attackmonster);

  // .dapi.commands.AttackXY attackXY = 9;
  bool has_attackxy() const;
  void clear_attackxy();
  static const int kAttackXYFieldNumber = 9;
  private:
  const ::dapi::commands::AttackXY& _internal_attackxy() const;
  public:
  const ::dapi::commands::AttackXY& attackxy() const;
  ::dapi::commands::AttackXY* release_attackxy();
  ::dapi::commands::AttackXY* mutable_attackxy();
  void set_allocated_attackxy(::dapi::commands::AttackXY* attackxy);

  // .dapi.commands.OperateObject operateObject = 10;
  bool has_operateobject() const;
  void clear_operateobject();
  static const int kOperateObjectFieldNumber = 10;
  private:
  const ::dapi::commands::OperateObject& _internal_operateobject() const;
  public:
  const ::dapi::commands::OperateObject& operateobject() const;
  ::dapi::commands::OperateObject* release_operateobject();
  ::dapi::commands::OperateObject* mutable_operateobject();
  void set_allocated_operateobject(::dapi::commands::OperateObject* operateobject);

  // .dapi.commands.UseBeltItem useBeltItem = 11;
  bool has_usebeltitem() const;
  void clear_usebeltitem();
  static const int kUseBeltItemFieldNumber = 11;
  private:
  const ::dapi::commands::UseBeltItem& _internal_usebeltitem() const;
  public:
  const ::dapi::commands::UseBeltItem& usebeltitem() const;
  ::dapi::commands::UseBeltItem* release_usebeltitem();
  ::dapi::commands::UseBeltItem* mutable_usebeltitem();
  void set_allocated_usebeltitem(::dapi::commands::UseBeltItem* usebeltitem);

  // .dapi.commands.ToggleCharacterSheet toggleCharacterSheet = 12;
  bool has_togglecharactersheet() const;
  void clear_togglecharactersheet();
  static const int kToggleCharacterSheetFieldNumber = 12;
  private:
  const ::dapi::commands::ToggleCharacterSheet& _internal_togglecharactersheet() const;
  public:
  const ::dapi::commands::ToggleCharacterSheet& togglecharactersheet() const;
  ::dapi::commands::ToggleCharacterSheet* release_togglecharactersheet();
  ::dapi::commands::ToggleCharacterSheet* mutable_togglecharactersheet();
  void set_allocated_togglecharactersheet(::dapi::commands::ToggleCharacterSheet* togglecharactersheet);

  // .dapi.commands.IncreaseStat increaseStat = 13;
  bool has_increasestat() const;
  void clear_increasestat();
  static const int kIncreaseStatFieldNumber = 13;
  private:
  const ::dapi::commands::IncreaseStat& _internal_increasestat() const;
  public:
  const ::dapi::commands::IncreaseStat& increasestat() const;
  ::dapi::commands::IncreaseStat* release_increasestat();
  ::dapi::commands::IncreaseStat* mutable_increasestat();
  void set_allocated_increasestat(::dapi::commands::IncreaseStat* increasestat);

  // .dapi.commands.GetItem getItem = 14;
  bool has_getitem() const;
  void clear_getitem();
  static const int kGetItemFieldNumber = 14;
  private:
  const ::dapi::commands::GetItem& _internal_getitem() const;
  public:
  const ::dapi::commands::GetItem& getitem() const;
  ::dapi::commands::GetItem* release_getitem();
  ::dapi::commands::GetItem* mutable_getitem();
  void set_allocated_getitem(::dapi::commands::GetItem* getitem);

  // .dapi.commands.SetSpell setSpell = 15;
  bool has_setspell() const;
  void clear_setspell();
  static const int kSetSpellFieldNumber = 15;
  private:
  const ::dapi::commands::SetSpell& _internal_setspell() const;
  public:
  const ::dapi::commands::SetSpell& setspell() const;
  ::dapi::commands::SetSpell* release_setspell();
  ::dapi::commands::SetSpell* mutable_setspell();
  void set_allocated_setspell(::dapi::commands::SetSpell* setspell);

  // .dapi.commands.CastMonster castMonster = 16;
  bool has_castmonster() const;
  void clear_castmonster();
  static const int kCastMonsterFieldNumber = 16;
  private:
  const ::dapi::commands::CastMonster& _internal_castmonster() const;
  public:
  const ::dapi::commands::CastMonster& castmonster() const;
  ::dapi::commands::CastMonster* release_castmonster();
  ::dapi::commands::CastMonster* mutable_castmonster();
  void set_allocated_castmonster(::dapi::commands::CastMonster* castmonster);

  // .dapi.commands.CastXY castXY = 17;
  bool has_castxy() const;
  void clear_castxy();
  static const int kCastXYFieldNumber = 17;
  private:
  const ::dapi::commands::CastXY& _internal_castxy() const;
  public:
  const ::dapi::commands::CastXY& castxy() const;
  ::dapi::commands::CastXY* release_castxy();
  ::dapi::commands::CastXY* mutable_castxy();
  void set_allocated_castxy(::dapi::commands::CastXY* castxy);

  // .dapi.commands.ToggleInventory toggleInventory = 18;
  bool has_toggleinventory() const;
  void clear_toggleinventory();
  static const int kToggleInventoryFieldNumber = 18;
  private:
  const ::dapi::commands::ToggleInventory& _internal_toggleinventory() const;
  public:
  const ::dapi::commands::ToggleInventory& toggleinventory() const;
  ::dapi::commands::ToggleInventory* release_toggleinventory();
  ::dapi::commands::ToggleInventory* mutable_toggleinventory();
  void set_allocated_toggleinventory(::dapi::commands::ToggleInventory* toggleinventory);

  // .dapi.commands.PutInCursor putInCursor = 19;
  bool has_putincursor() const;
  void clear_putincursor();
  static const int kPutInCursorFieldNumber = 19;
  private:
  const ::dapi::commands::PutInCursor& _internal_putincursor() const;
  public:
  const ::dapi::commands::PutInCursor& putincursor() const;
  ::dapi::commands::PutInCursor* release_putincursor();
  ::dapi::commands::PutInCursor* mutable_putincursor();
  void set_allocated_putincursor(::dapi::commands::PutInCursor* putincursor);

  // .dapi.commands.PutCursorItem putCursorItem = 20;
  bool has_putcursoritem() const;
  void clear_putcursoritem();
  static const int kPutCursorItemFieldNumber = 20;
  private:
  const ::dapi::commands::PutCursorItem& _internal_putcursoritem() const;
  public:
  const ::dapi::commands::PutCursorItem& putcursoritem() const;
  ::dapi::commands::PutCursorItem* release_putcursoritem();
  ::dapi::commands::PutCursorItem* mutable_putcursoritem();
  void set_allocated_putcursoritem(::dapi::commands::PutCursorItem* putcursoritem);

  // .dapi.commands.DropCursorItem dropCursorItem = 21;
  bool has_dropcursoritem() const;
  void clear_dropcursoritem();
  static const int kDropCursorItemFieldNumber = 21;
  private:
  const ::dapi::commands::DropCursorItem& _internal_dropcursoritem() const;
  public:
  const ::dapi::commands::DropCursorItem& dropcursoritem() const;
  ::dapi::commands::DropCursorItem* release_dropcursoritem();
  ::dapi::commands::DropCursorItem* mutable_dropcursoritem();
  void set_allocated_dropcursoritem(::dapi::commands::DropCursorItem* dropcursoritem);

  // .dapi.commands.UseItem useItem = 22;
  bool has_useitem() const;
  void clear_useitem();
  static const int kUseItemFieldNumber = 22;
  private:
  const ::dapi::commands::UseItem& _internal_useitem() const;
  public:
  const ::dapi::commands::UseItem& useitem() const;
  ::dapi::commands::UseItem* release_useitem();
  ::dapi::commands::UseItem* mutable_useitem();
  void set_allocated_useitem(::dapi::commands::UseItem* useitem);

  // .dapi.commands.IdentifyStoreItem identifyStoreItem = 23;
  bool has_identifystoreitem() const;
  void clear_identifystoreitem();
  static const int kIdentifyStoreItemFieldNumber = 23;
  private:
  const ::dapi::commands::IdentifyStoreItem& _internal_identifystoreitem() const;
  public:
  const ::dapi::commands::IdentifyStoreItem& identifystoreitem() const;
  ::dapi::commands::IdentifyStoreItem* release_identifystoreitem();
  ::dapi::commands::IdentifyStoreItem* mutable_identifystoreitem();
  void set_allocated_identifystoreitem(::dapi::commands::IdentifyStoreItem* identifystoreitem);

  // .dapi.commands.CancelQText cancelQText = 24;
  bool has_cancelqtext() const;
  void clear_cancelqtext();
  static const int kCancelQTextFieldNumber = 24;
  private:
  const ::dapi::commands::CancelQText& _internal_cancelqtext() const;
  public:
  const ::dapi::commands::CancelQText& cancelqtext() const;
  ::dapi::commands::CancelQText* release_cancelqtext();
  ::dapi::commands::CancelQText* mutable_cancelqtext();
  void set_allocated_cancelqtext(::dapi::commands::CancelQText* cancelqtext);

  // .dapi.commands.SetFPS setFPS = 25;
  bool has_setfps() const;
  void clear_setfps();
  static const int kSetFPSFieldNumber = 25;
  private:
  const ::dapi::commands::SetFPS& _internal_setfps() const;
  public:
  const ::dapi::commands::SetFPS& setfps() const;
  ::dapi::commands::SetFPS* release_setfps();
  ::dapi::commands::SetFPS* mutable_setfps();
  void set_allocated_setfps(::dapi::commands::SetFPS* setfps);

  // .dapi.commands.DisarmTrap disarmTrap = 26;
  bool has_disarmtrap() const;
  void clear_disarmtrap();
  static const int kDisarmTrapFieldNumber = 26;
  private:
  const ::dapi::commands::DisarmTrap& _internal_disarmtrap() const;
  public:
  const ::dapi::commands::DisarmTrap& disarmtrap() const;
  ::dapi::commands::DisarmTrap* release_disarmtrap();
  ::dapi::commands::DisarmTrap* mutable_disarmtrap();
  void set_allocated_disarmtrap(::dapi::commands::DisarmTrap* disarmtrap);

  // .dapi.commands.SkillRepair skillRepair = 27;
  bool has_skillrepair() const;
  void clear_skillrepair();
  static const int kSkillRepairFieldNumber = 27;
  private:
  const ::dapi::commands::SkillRepair& _internal_skillrepair() const;
  public:
  const ::dapi::commands::SkillRepair& skillrepair() const;
  ::dapi::commands::SkillRepair* release_skillrepair();
  ::dapi::commands::SkillRepair* mutable_skillrepair();
  void set_allocated_skillrepair(::dapi::commands::SkillRepair* skillrepair);

  // .dapi.commands.SkillRecharge skillRecharge = 28;
  bool has_skillrecharge() const;
  void clear_skillrecharge();
  static const int kSkillRechargeFieldNumber = 28;
  private:
  const ::dapi::commands::SkillRecharge& _internal_skillrecharge() const;
  public:
  const ::dapi::commands::SkillRecharge& skillrecharge() const;
  ::dapi::commands::SkillRecharge* release_skillrecharge();
  ::dapi::commands::SkillRecharge* mutable_skillrecharge();
  void set_allocated_skillrecharge(::dapi::commands::SkillRecharge* skillrecharge);

  // .dapi.commands.ToggleMenu toggleMenu = 29;
  bool has_togglemenu() const;
  void clear_togglemenu();
  static const int kToggleMenuFieldNumber = 29;
  private:
  const ::dapi::commands::ToggleMenu& _internal_togglemenu() const;
  public:
  const ::dapi::commands::ToggleMenu& togglemenu() const;
  ::dapi::commands::ToggleMenu* release_togglemenu();
  ::dapi::commands::ToggleMenu* mutable_togglemenu();
  void set_allocated_togglemenu(::dapi::commands::ToggleMenu* togglemenu);

  // .dapi.commands.SaveGame saveGame = 30;
  bool has_savegame() const;
  void clear_savegame();
  static const int kSaveGameFieldNumber = 30;
  private:
  const ::dapi::commands::SaveGame& _internal_savegame() const;
  public:
  const ::dapi::commands::SaveGame& savegame() const;
  ::dapi::commands::SaveGame* release_savegame();
  ::dapi::commands::SaveGame* mutable_savegame();
  void set_allocated_savegame(::dapi::commands::SaveGame* savegame);

  // .dapi.commands.Quit quit = 31;
  bool has_quit() const;
  void clear_quit();
  static const int kQuitFieldNumber = 31;
  private:
  const ::dapi::commands::Quit& _internal_quit() const;
  public:
  const ::dapi::commands::Quit& quit() const;
  ::dapi::commands::Quit* release_quit();
  ::dapi::commands::Quit* mutable_quit();
  void set_allocated_quit(::dapi::commands::Quit* quit);

  // .dapi.commands.ClearCursor clearCursor = 32;
  bool has_clearcursor() const;
  void clear_clearcursor();
  static const int kClearCursorFieldNumber = 32;
  private:
  const ::dapi::commands::ClearCursor& _internal_clearcursor() const;
  public:
  const ::dapi::commands::ClearCursor& clearcursor() const;
  ::dapi::commands::ClearCursor* release_clearcursor();
  ::dapi::commands::ClearCursor* mutable_clearcursor();
  void set_allocated_clearcursor(::dapi::commands::ClearCursor* clearcursor);

  // .dapi.commands.IdentifyItem identifyItem = 33;
  bool has_identifyitem() const;
  void clear_identifyitem();
  static const int kIdentifyItemFieldNumber = 33;
  private:
  const ::dapi::commands::IdentifyItem& _internal_identifyitem() const;
  public:
  const ::dapi::commands::IdentifyItem& identifyitem() const;
  ::dapi::commands::IdentifyItem* release_identifyitem();
  ::dapi::commands::IdentifyItem* mutable_identifyitem();
  void set_allocated_identifyitem(::dapi::commands::IdentifyItem* identifyitem);

  // .dapi.commands.SendChat sendChat = 34;
  bool has_sendchat() const;
  void clear_sendchat();
  static const int kSendChatFieldNumber = 34;
  private:
  const ::dapi::commands::SendChat& _internal_sendchat() const;
  public:
  const ::dapi::commands::SendChat& sendchat() const;
  ::dapi::commands::SendChat* release_sendchat();
  ::dapi::commands::SendChat* mutable_sendchat();
  void set_allocated_sendchat(::dapi::commands::SendChat* sendchat);

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:dapi.commands.Command)
 private:
  void set_has_move();
  void set_has_talk();
  void set_has_option();
  void set_has_buyitem();
  void set_has_sellitem();
  void set_has_rechargeitem();
  void set_has_repairitem();
  void set_has_attackmonster();
  void set_has_attackxy();
  void set_has_operateobject();
  void set_has_usebeltitem();
  void set_has_togglecharactersheet();
  void set_has_increasestat();
  void set_has_getitem();
  void set_has_setspell();
  void set_has_castmonster();
  void set_has_castxy();
  void set_has_toggleinventory();
  void set_has_putincursor();
  void set_has_putcursoritem();
  void set_has_dropcursoritem();
  void set_has_useitem();
  void set_has_identifystoreitem();
  void set_has_cancelqtext();
  void set_has_setfps();
  void set_has_disarmtrap();
  void set_has_skillrepair();
  void set_has_skillrecharge();
  void set_has_togglemenu();
  void set_has_savegame();
  void set_has_quit();
  void set_has_clearcursor();
  void set_has_identifyitem();
  void set_has_sendchat();

  inline bool has_command() const;
  inline void clear_has_command();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union CommandUnion {
    CommandUnion() {}
    ::dapi::commands::Move* move_;
    ::dapi::commands::Talk* talk_;
    ::dapi::commands::SelectStoreOption* option_;
    ::dapi::commands::BuyItem* buyitem_;
    ::dapi::commands::SellItem* sellitem_;
    ::dapi::commands::RechargeItem* rechargeitem_;
    ::dapi::commands::RepairItem* repairitem_;
    ::dapi::commands::AttackMonster* attackmonster_;
    ::dapi::commands::AttackXY* attackxy_;
    ::dapi::commands::OperateObject* operateobject_;
    ::dapi::commands::UseBeltItem* usebeltitem_;
    ::dapi::commands::ToggleCharacterSheet* togglecharactersheet_;
    ::dapi::commands::IncreaseStat* increasestat_;
    ::dapi::commands::GetItem* getitem_;
    ::dapi::commands::SetSpell* setspell_;
    ::dapi::commands::CastMonster* castmonster_;
    ::dapi::commands::CastXY* castxy_;
    ::dapi::commands::ToggleInventory* toggleinventory_;
    ::dapi::commands::PutInCursor* putincursor_;
    ::dapi::commands::PutCursorItem* putcursoritem_;
    ::dapi::commands::DropCursorItem* dropcursoritem_;
    ::dapi::commands::UseItem* useitem_;
    ::dapi::commands::IdentifyStoreItem* identifystoreitem_;
    ::dapi::commands::CancelQText* cancelqtext_;
    ::dapi::commands::SetFPS* setfps_;
    ::dapi::commands::DisarmTrap* disarmtrap_;
    ::dapi::commands::SkillRepair* skillrepair_;
    ::dapi::commands::SkillRecharge* skillrecharge_;
    ::dapi::commands::ToggleMenu* togglemenu_;
    ::dapi::commands::SaveGame* savegame_;
    ::dapi::commands::Quit* quit_;
    ::dapi::commands::ClearCursor* clearcursor_;
    ::dapi::commands::IdentifyItem* identifyitem_;
    ::dapi::commands::SendChat* sendchat_;
  } command_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_command_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SetFPS

// uint32 FPS = 1;
inline void SetFPS::clear_fps() {
  fps_ = 0u;
}
inline ::google::protobuf::uint32 SetFPS::fps() const {
  // @@protoc_insertion_point(field_get:dapi.commands.SetFPS.FPS)
  return fps_;
}
inline void SetFPS::set_fps(::google::protobuf::uint32 value) {
  
  fps_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.SetFPS.FPS)
}

// -------------------------------------------------------------------

// CancelQText

// -------------------------------------------------------------------

// Move

// uint32 type = 1;
inline void Move::clear_type() {
  type_ = 0u;
}
inline ::google::protobuf::uint32 Move::type() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Move.type)
  return type_;
}
inline void Move::set_type(::google::protobuf::uint32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.Move.type)
}

// uint32 targetX = 2;
inline void Move::clear_targetx() {
  targetx_ = 0u;
}
inline ::google::protobuf::uint32 Move::targetx() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Move.targetX)
  return targetx_;
}
inline void Move::set_targetx(::google::protobuf::uint32 value) {
  
  targetx_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.Move.targetX)
}

// uint32 targetY = 3;
inline void Move::clear_targety() {
  targety_ = 0u;
}
inline ::google::protobuf::uint32 Move::targety() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Move.targetY)
  return targety_;
}
inline void Move::set_targety(::google::protobuf::uint32 value) {
  
  targety_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.Move.targetY)
}

// -------------------------------------------------------------------

// Talk

// uint32 targetX = 1;
inline void Talk::clear_targetx() {
  targetx_ = 0u;
}
inline ::google::protobuf::uint32 Talk::targetx() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Talk.targetX)
  return targetx_;
}
inline void Talk::set_targetx(::google::protobuf::uint32 value) {
  
  targetx_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.Talk.targetX)
}

// uint32 targetY = 2;
inline void Talk::clear_targety() {
  targety_ = 0u;
}
inline ::google::protobuf::uint32 Talk::targety() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Talk.targetY)
  return targety_;
}
inline void Talk::set_targety(::google::protobuf::uint32 value) {
  
  targety_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.Talk.targetY)
}

// -------------------------------------------------------------------

// SelectStoreOption

// uint32 option = 1;
inline void SelectStoreOption::clear_option() {
  option_ = 0u;
}
inline ::google::protobuf::uint32 SelectStoreOption::option() const {
  // @@protoc_insertion_point(field_get:dapi.commands.SelectStoreOption.option)
  return option_;
}
inline void SelectStoreOption::set_option(::google::protobuf::uint32 value) {
  
  option_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.SelectStoreOption.option)
}

// -------------------------------------------------------------------

// BuyItem

// uint32 ID = 1;
inline void BuyItem::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 BuyItem::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.BuyItem.ID)
  return id_;
}
inline void BuyItem::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.BuyItem.ID)
}

// -------------------------------------------------------------------

// SellItem

// uint32 ID = 1;
inline void SellItem::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 SellItem::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.SellItem.ID)
  return id_;
}
inline void SellItem::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.SellItem.ID)
}

// -------------------------------------------------------------------

// RechargeItem

// uint32 ID = 1;
inline void RechargeItem::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 RechargeItem::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.RechargeItem.ID)
  return id_;
}
inline void RechargeItem::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.RechargeItem.ID)
}

// -------------------------------------------------------------------

// RepairItem

// uint32 ID = 1;
inline void RepairItem::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 RepairItem::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.RepairItem.ID)
  return id_;
}
inline void RepairItem::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.RepairItem.ID)
}

// -------------------------------------------------------------------

// AttackMonster

// uint32 index = 1;
inline void AttackMonster::clear_index() {
  index_ = 0u;
}
inline ::google::protobuf::uint32 AttackMonster::index() const {
  // @@protoc_insertion_point(field_get:dapi.commands.AttackMonster.index)
  return index_;
}
inline void AttackMonster::set_index(::google::protobuf::uint32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.AttackMonster.index)
}

// -------------------------------------------------------------------

// AttackXY

// sint32 x = 1;
inline void AttackXY::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 AttackXY::x() const {
  // @@protoc_insertion_point(field_get:dapi.commands.AttackXY.x)
  return x_;
}
inline void AttackXY::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.AttackXY.x)
}

// sint32 y = 2;
inline void AttackXY::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 AttackXY::y() const {
  // @@protoc_insertion_point(field_get:dapi.commands.AttackXY.y)
  return y_;
}
inline void AttackXY::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.AttackXY.y)
}

// -------------------------------------------------------------------

// OperateObject

// uint32 index = 1;
inline void OperateObject::clear_index() {
  index_ = 0u;
}
inline ::google::protobuf::uint32 OperateObject::index() const {
  // @@protoc_insertion_point(field_get:dapi.commands.OperateObject.index)
  return index_;
}
inline void OperateObject::set_index(::google::protobuf::uint32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.OperateObject.index)
}

// -------------------------------------------------------------------

// UseBeltItem

// uint32 slot = 1;
inline void UseBeltItem::clear_slot() {
  slot_ = 0u;
}
inline ::google::protobuf::uint32 UseBeltItem::slot() const {
  // @@protoc_insertion_point(field_get:dapi.commands.UseBeltItem.slot)
  return slot_;
}
inline void UseBeltItem::set_slot(::google::protobuf::uint32 value) {
  
  slot_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.UseBeltItem.slot)
}

// -------------------------------------------------------------------

// ToggleCharacterSheet

// -------------------------------------------------------------------

// IncreaseStat

// uint32 stat = 1;
inline void IncreaseStat::clear_stat() {
  stat_ = 0u;
}
inline ::google::protobuf::uint32 IncreaseStat::stat() const {
  // @@protoc_insertion_point(field_get:dapi.commands.IncreaseStat.stat)
  return stat_;
}
inline void IncreaseStat::set_stat(::google::protobuf::uint32 value) {
  
  stat_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.IncreaseStat.stat)
}

// -------------------------------------------------------------------

// GetItem

// uint32 ID = 1;
inline void GetItem::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 GetItem::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.GetItem.ID)
  return id_;
}
inline void GetItem::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.GetItem.ID)
}

// -------------------------------------------------------------------

// SetSpell

// sint32 spellID = 1;
inline void SetSpell::clear_spellid() {
  spellid_ = 0;
}
inline ::google::protobuf::int32 SetSpell::spellid() const {
  // @@protoc_insertion_point(field_get:dapi.commands.SetSpell.spellID)
  return spellid_;
}
inline void SetSpell::set_spellid(::google::protobuf::int32 value) {
  
  spellid_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.SetSpell.spellID)
}

// sint32 spellType = 2;
inline void SetSpell::clear_spelltype() {
  spelltype_ = 0;
}
inline ::google::protobuf::int32 SetSpell::spelltype() const {
  // @@protoc_insertion_point(field_get:dapi.commands.SetSpell.spellType)
  return spelltype_;
}
inline void SetSpell::set_spelltype(::google::protobuf::int32 value) {
  
  spelltype_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.SetSpell.spellType)
}

// -------------------------------------------------------------------

// CastMonster

// uint32 index = 1;
inline void CastMonster::clear_index() {
  index_ = 0u;
}
inline ::google::protobuf::uint32 CastMonster::index() const {
  // @@protoc_insertion_point(field_get:dapi.commands.CastMonster.index)
  return index_;
}
inline void CastMonster::set_index(::google::protobuf::uint32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.CastMonster.index)
}

// -------------------------------------------------------------------

// CastXY

// sint32 x = 1;
inline void CastXY::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 CastXY::x() const {
  // @@protoc_insertion_point(field_get:dapi.commands.CastXY.x)
  return x_;
}
inline void CastXY::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.CastXY.x)
}

// sint32 y = 2;
inline void CastXY::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 CastXY::y() const {
  // @@protoc_insertion_point(field_get:dapi.commands.CastXY.y)
  return y_;
}
inline void CastXY::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.CastXY.y)
}

// -------------------------------------------------------------------

// ToggleInventory

// -------------------------------------------------------------------

// PutInCursor

// uint32 ID = 1;
inline void PutInCursor::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 PutInCursor::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.PutInCursor.ID)
  return id_;
}
inline void PutInCursor::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.PutInCursor.ID)
}

// -------------------------------------------------------------------

// PutCursorItem

// sint32 target = 1;
inline void PutCursorItem::clear_target() {
  target_ = 0;
}
inline ::google::protobuf::int32 PutCursorItem::target() const {
  // @@protoc_insertion_point(field_get:dapi.commands.PutCursorItem.target)
  return target_;
}
inline void PutCursorItem::set_target(::google::protobuf::int32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.PutCursorItem.target)
}

// -------------------------------------------------------------------

// DropCursorItem

// -------------------------------------------------------------------

// UseItem

// uint32 ID = 1;
inline void UseItem::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 UseItem::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.UseItem.ID)
  return id_;
}
inline void UseItem::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.UseItem.ID)
}

// -------------------------------------------------------------------

// IdentifyStoreItem

// uint32 ID = 1;
inline void IdentifyStoreItem::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 IdentifyStoreItem::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.IdentifyStoreItem.ID)
  return id_;
}
inline void IdentifyStoreItem::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.IdentifyStoreItem.ID)
}

// -------------------------------------------------------------------

// DisarmTrap

// uint32 index = 1;
inline void DisarmTrap::clear_index() {
  index_ = 0u;
}
inline ::google::protobuf::uint32 DisarmTrap::index() const {
  // @@protoc_insertion_point(field_get:dapi.commands.DisarmTrap.index)
  return index_;
}
inline void DisarmTrap::set_index(::google::protobuf::uint32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.DisarmTrap.index)
}

// -------------------------------------------------------------------

// SkillRepair

// uint32 ID = 1;
inline void SkillRepair::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 SkillRepair::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.SkillRepair.ID)
  return id_;
}
inline void SkillRepair::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.SkillRepair.ID)
}

// -------------------------------------------------------------------

// SkillRecharge

// uint32 ID = 1;
inline void SkillRecharge::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 SkillRecharge::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.SkillRecharge.ID)
  return id_;
}
inline void SkillRecharge::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.SkillRecharge.ID)
}

// -------------------------------------------------------------------

// ToggleMenu

// -------------------------------------------------------------------

// SaveGame

// -------------------------------------------------------------------

// Quit

// -------------------------------------------------------------------

// ClearCursor

// -------------------------------------------------------------------

// IdentifyItem

// uint32 ID = 1;
inline void IdentifyItem::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 IdentifyItem::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.IdentifyItem.ID)
  return id_;
}
inline void IdentifyItem::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:dapi.commands.IdentifyItem.ID)
}

// -------------------------------------------------------------------

// SendChat

// string message = 1;
inline void SendChat::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SendChat::message() const {
  // @@protoc_insertion_point(field_get:dapi.commands.SendChat.message)
  return message_.GetNoArena();
}
inline void SendChat::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dapi.commands.SendChat.message)
}
#if LANG_CXX11
inline void SendChat::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dapi.commands.SendChat.message)
}
#endif
inline void SendChat::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dapi.commands.SendChat.message)
}
inline void SendChat::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dapi.commands.SendChat.message)
}
inline ::std::string* SendChat::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:dapi.commands.SendChat.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendChat::release_message() {
  // @@protoc_insertion_point(field_release:dapi.commands.SendChat.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendChat::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:dapi.commands.SendChat.message)
}

// -------------------------------------------------------------------

// Command

// .dapi.commands.Move move = 1;
inline bool Command::has_move() const {
  return command_case() == kMove;
}
inline void Command::set_has_move() {
  _oneof_case_[0] = kMove;
}
inline void Command::clear_move() {
  if (has_move()) {
    delete command_.move_;
    clear_has_command();
  }
}
inline const ::dapi::commands::Move& Command::_internal_move() const {
  return *command_.move_;
}
inline ::dapi::commands::Move* Command::release_move() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.move)
  if (has_move()) {
    clear_has_command();
      ::dapi::commands::Move* temp = command_.move_;
    command_.move_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::Move& Command::move() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.move)
  return has_move()
      ? *command_.move_
      : *reinterpret_cast< ::dapi::commands::Move*>(&::dapi::commands::_Move_default_instance_);
}
inline ::dapi::commands::Move* Command::mutable_move() {
  if (!has_move()) {
    clear_command();
    set_has_move();
    command_.move_ = CreateMaybeMessage< ::dapi::commands::Move >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.move)
  return command_.move_;
}

// .dapi.commands.Talk talk = 2;
inline bool Command::has_talk() const {
  return command_case() == kTalk;
}
inline void Command::set_has_talk() {
  _oneof_case_[0] = kTalk;
}
inline void Command::clear_talk() {
  if (has_talk()) {
    delete command_.talk_;
    clear_has_command();
  }
}
inline const ::dapi::commands::Talk& Command::_internal_talk() const {
  return *command_.talk_;
}
inline ::dapi::commands::Talk* Command::release_talk() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.talk)
  if (has_talk()) {
    clear_has_command();
      ::dapi::commands::Talk* temp = command_.talk_;
    command_.talk_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::Talk& Command::talk() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.talk)
  return has_talk()
      ? *command_.talk_
      : *reinterpret_cast< ::dapi::commands::Talk*>(&::dapi::commands::_Talk_default_instance_);
}
inline ::dapi::commands::Talk* Command::mutable_talk() {
  if (!has_talk()) {
    clear_command();
    set_has_talk();
    command_.talk_ = CreateMaybeMessage< ::dapi::commands::Talk >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.talk)
  return command_.talk_;
}

// .dapi.commands.SelectStoreOption option = 3;
inline bool Command::has_option() const {
  return command_case() == kOption;
}
inline void Command::set_has_option() {
  _oneof_case_[0] = kOption;
}
inline void Command::clear_option() {
  if (has_option()) {
    delete command_.option_;
    clear_has_command();
  }
}
inline const ::dapi::commands::SelectStoreOption& Command::_internal_option() const {
  return *command_.option_;
}
inline ::dapi::commands::SelectStoreOption* Command::release_option() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.option)
  if (has_option()) {
    clear_has_command();
      ::dapi::commands::SelectStoreOption* temp = command_.option_;
    command_.option_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::SelectStoreOption& Command::option() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.option)
  return has_option()
      ? *command_.option_
      : *reinterpret_cast< ::dapi::commands::SelectStoreOption*>(&::dapi::commands::_SelectStoreOption_default_instance_);
}
inline ::dapi::commands::SelectStoreOption* Command::mutable_option() {
  if (!has_option()) {
    clear_command();
    set_has_option();
    command_.option_ = CreateMaybeMessage< ::dapi::commands::SelectStoreOption >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.option)
  return command_.option_;
}

// .dapi.commands.BuyItem buyItem = 4;
inline bool Command::has_buyitem() const {
  return command_case() == kBuyItem;
}
inline void Command::set_has_buyitem() {
  _oneof_case_[0] = kBuyItem;
}
inline void Command::clear_buyitem() {
  if (has_buyitem()) {
    delete command_.buyitem_;
    clear_has_command();
  }
}
inline const ::dapi::commands::BuyItem& Command::_internal_buyitem() const {
  return *command_.buyitem_;
}
inline ::dapi::commands::BuyItem* Command::release_buyitem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.buyItem)
  if (has_buyitem()) {
    clear_has_command();
      ::dapi::commands::BuyItem* temp = command_.buyitem_;
    command_.buyitem_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::BuyItem& Command::buyitem() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.buyItem)
  return has_buyitem()
      ? *command_.buyitem_
      : *reinterpret_cast< ::dapi::commands::BuyItem*>(&::dapi::commands::_BuyItem_default_instance_);
}
inline ::dapi::commands::BuyItem* Command::mutable_buyitem() {
  if (!has_buyitem()) {
    clear_command();
    set_has_buyitem();
    command_.buyitem_ = CreateMaybeMessage< ::dapi::commands::BuyItem >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.buyItem)
  return command_.buyitem_;
}

// .dapi.commands.SellItem sellItem = 5;
inline bool Command::has_sellitem() const {
  return command_case() == kSellItem;
}
inline void Command::set_has_sellitem() {
  _oneof_case_[0] = kSellItem;
}
inline void Command::clear_sellitem() {
  if (has_sellitem()) {
    delete command_.sellitem_;
    clear_has_command();
  }
}
inline const ::dapi::commands::SellItem& Command::_internal_sellitem() const {
  return *command_.sellitem_;
}
inline ::dapi::commands::SellItem* Command::release_sellitem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.sellItem)
  if (has_sellitem()) {
    clear_has_command();
      ::dapi::commands::SellItem* temp = command_.sellitem_;
    command_.sellitem_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::SellItem& Command::sellitem() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.sellItem)
  return has_sellitem()
      ? *command_.sellitem_
      : *reinterpret_cast< ::dapi::commands::SellItem*>(&::dapi::commands::_SellItem_default_instance_);
}
inline ::dapi::commands::SellItem* Command::mutable_sellitem() {
  if (!has_sellitem()) {
    clear_command();
    set_has_sellitem();
    command_.sellitem_ = CreateMaybeMessage< ::dapi::commands::SellItem >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.sellItem)
  return command_.sellitem_;
}

// .dapi.commands.RechargeItem rechargeItem = 6;
inline bool Command::has_rechargeitem() const {
  return command_case() == kRechargeItem;
}
inline void Command::set_has_rechargeitem() {
  _oneof_case_[0] = kRechargeItem;
}
inline void Command::clear_rechargeitem() {
  if (has_rechargeitem()) {
    delete command_.rechargeitem_;
    clear_has_command();
  }
}
inline const ::dapi::commands::RechargeItem& Command::_internal_rechargeitem() const {
  return *command_.rechargeitem_;
}
inline ::dapi::commands::RechargeItem* Command::release_rechargeitem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.rechargeItem)
  if (has_rechargeitem()) {
    clear_has_command();
      ::dapi::commands::RechargeItem* temp = command_.rechargeitem_;
    command_.rechargeitem_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::RechargeItem& Command::rechargeitem() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.rechargeItem)
  return has_rechargeitem()
      ? *command_.rechargeitem_
      : *reinterpret_cast< ::dapi::commands::RechargeItem*>(&::dapi::commands::_RechargeItem_default_instance_);
}
inline ::dapi::commands::RechargeItem* Command::mutable_rechargeitem() {
  if (!has_rechargeitem()) {
    clear_command();
    set_has_rechargeitem();
    command_.rechargeitem_ = CreateMaybeMessage< ::dapi::commands::RechargeItem >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.rechargeItem)
  return command_.rechargeitem_;
}

// .dapi.commands.RepairItem repairItem = 7;
inline bool Command::has_repairitem() const {
  return command_case() == kRepairItem;
}
inline void Command::set_has_repairitem() {
  _oneof_case_[0] = kRepairItem;
}
inline void Command::clear_repairitem() {
  if (has_repairitem()) {
    delete command_.repairitem_;
    clear_has_command();
  }
}
inline const ::dapi::commands::RepairItem& Command::_internal_repairitem() const {
  return *command_.repairitem_;
}
inline ::dapi::commands::RepairItem* Command::release_repairitem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.repairItem)
  if (has_repairitem()) {
    clear_has_command();
      ::dapi::commands::RepairItem* temp = command_.repairitem_;
    command_.repairitem_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::RepairItem& Command::repairitem() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.repairItem)
  return has_repairitem()
      ? *command_.repairitem_
      : *reinterpret_cast< ::dapi::commands::RepairItem*>(&::dapi::commands::_RepairItem_default_instance_);
}
inline ::dapi::commands::RepairItem* Command::mutable_repairitem() {
  if (!has_repairitem()) {
    clear_command();
    set_has_repairitem();
    command_.repairitem_ = CreateMaybeMessage< ::dapi::commands::RepairItem >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.repairItem)
  return command_.repairitem_;
}

// .dapi.commands.AttackMonster attackMonster = 8;
inline bool Command::has_attackmonster() const {
  return command_case() == kAttackMonster;
}
inline void Command::set_has_attackmonster() {
  _oneof_case_[0] = kAttackMonster;
}
inline void Command::clear_attackmonster() {
  if (has_attackmonster()) {
    delete command_.attackmonster_;
    clear_has_command();
  }
}
inline const ::dapi::commands::AttackMonster& Command::_internal_attackmonster() const {
  return *command_.attackmonster_;
}
inline ::dapi::commands::AttackMonster* Command::release_attackmonster() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.attackMonster)
  if (has_attackmonster()) {
    clear_has_command();
      ::dapi::commands::AttackMonster* temp = command_.attackmonster_;
    command_.attackmonster_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::AttackMonster& Command::attackmonster() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.attackMonster)
  return has_attackmonster()
      ? *command_.attackmonster_
      : *reinterpret_cast< ::dapi::commands::AttackMonster*>(&::dapi::commands::_AttackMonster_default_instance_);
}
inline ::dapi::commands::AttackMonster* Command::mutable_attackmonster() {
  if (!has_attackmonster()) {
    clear_command();
    set_has_attackmonster();
    command_.attackmonster_ = CreateMaybeMessage< ::dapi::commands::AttackMonster >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.attackMonster)
  return command_.attackmonster_;
}

// .dapi.commands.AttackXY attackXY = 9;
inline bool Command::has_attackxy() const {
  return command_case() == kAttackXY;
}
inline void Command::set_has_attackxy() {
  _oneof_case_[0] = kAttackXY;
}
inline void Command::clear_attackxy() {
  if (has_attackxy()) {
    delete command_.attackxy_;
    clear_has_command();
  }
}
inline const ::dapi::commands::AttackXY& Command::_internal_attackxy() const {
  return *command_.attackxy_;
}
inline ::dapi::commands::AttackXY* Command::release_attackxy() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.attackXY)
  if (has_attackxy()) {
    clear_has_command();
      ::dapi::commands::AttackXY* temp = command_.attackxy_;
    command_.attackxy_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::AttackXY& Command::attackxy() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.attackXY)
  return has_attackxy()
      ? *command_.attackxy_
      : *reinterpret_cast< ::dapi::commands::AttackXY*>(&::dapi::commands::_AttackXY_default_instance_);
}
inline ::dapi::commands::AttackXY* Command::mutable_attackxy() {
  if (!has_attackxy()) {
    clear_command();
    set_has_attackxy();
    command_.attackxy_ = CreateMaybeMessage< ::dapi::commands::AttackXY >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.attackXY)
  return command_.attackxy_;
}

// .dapi.commands.OperateObject operateObject = 10;
inline bool Command::has_operateobject() const {
  return command_case() == kOperateObject;
}
inline void Command::set_has_operateobject() {
  _oneof_case_[0] = kOperateObject;
}
inline void Command::clear_operateobject() {
  if (has_operateobject()) {
    delete command_.operateobject_;
    clear_has_command();
  }
}
inline const ::dapi::commands::OperateObject& Command::_internal_operateobject() const {
  return *command_.operateobject_;
}
inline ::dapi::commands::OperateObject* Command::release_operateobject() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.operateObject)
  if (has_operateobject()) {
    clear_has_command();
      ::dapi::commands::OperateObject* temp = command_.operateobject_;
    command_.operateobject_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::OperateObject& Command::operateobject() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.operateObject)
  return has_operateobject()
      ? *command_.operateobject_
      : *reinterpret_cast< ::dapi::commands::OperateObject*>(&::dapi::commands::_OperateObject_default_instance_);
}
inline ::dapi::commands::OperateObject* Command::mutable_operateobject() {
  if (!has_operateobject()) {
    clear_command();
    set_has_operateobject();
    command_.operateobject_ = CreateMaybeMessage< ::dapi::commands::OperateObject >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.operateObject)
  return command_.operateobject_;
}

// .dapi.commands.UseBeltItem useBeltItem = 11;
inline bool Command::has_usebeltitem() const {
  return command_case() == kUseBeltItem;
}
inline void Command::set_has_usebeltitem() {
  _oneof_case_[0] = kUseBeltItem;
}
inline void Command::clear_usebeltitem() {
  if (has_usebeltitem()) {
    delete command_.usebeltitem_;
    clear_has_command();
  }
}
inline const ::dapi::commands::UseBeltItem& Command::_internal_usebeltitem() const {
  return *command_.usebeltitem_;
}
inline ::dapi::commands::UseBeltItem* Command::release_usebeltitem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.useBeltItem)
  if (has_usebeltitem()) {
    clear_has_command();
      ::dapi::commands::UseBeltItem* temp = command_.usebeltitem_;
    command_.usebeltitem_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::UseBeltItem& Command::usebeltitem() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.useBeltItem)
  return has_usebeltitem()
      ? *command_.usebeltitem_
      : *reinterpret_cast< ::dapi::commands::UseBeltItem*>(&::dapi::commands::_UseBeltItem_default_instance_);
}
inline ::dapi::commands::UseBeltItem* Command::mutable_usebeltitem() {
  if (!has_usebeltitem()) {
    clear_command();
    set_has_usebeltitem();
    command_.usebeltitem_ = CreateMaybeMessage< ::dapi::commands::UseBeltItem >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.useBeltItem)
  return command_.usebeltitem_;
}

// .dapi.commands.ToggleCharacterSheet toggleCharacterSheet = 12;
inline bool Command::has_togglecharactersheet() const {
  return command_case() == kToggleCharacterSheet;
}
inline void Command::set_has_togglecharactersheet() {
  _oneof_case_[0] = kToggleCharacterSheet;
}
inline void Command::clear_togglecharactersheet() {
  if (has_togglecharactersheet()) {
    delete command_.togglecharactersheet_;
    clear_has_command();
  }
}
inline const ::dapi::commands::ToggleCharacterSheet& Command::_internal_togglecharactersheet() const {
  return *command_.togglecharactersheet_;
}
inline ::dapi::commands::ToggleCharacterSheet* Command::release_togglecharactersheet() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.toggleCharacterSheet)
  if (has_togglecharactersheet()) {
    clear_has_command();
      ::dapi::commands::ToggleCharacterSheet* temp = command_.togglecharactersheet_;
    command_.togglecharactersheet_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::ToggleCharacterSheet& Command::togglecharactersheet() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.toggleCharacterSheet)
  return has_togglecharactersheet()
      ? *command_.togglecharactersheet_
      : *reinterpret_cast< ::dapi::commands::ToggleCharacterSheet*>(&::dapi::commands::_ToggleCharacterSheet_default_instance_);
}
inline ::dapi::commands::ToggleCharacterSheet* Command::mutable_togglecharactersheet() {
  if (!has_togglecharactersheet()) {
    clear_command();
    set_has_togglecharactersheet();
    command_.togglecharactersheet_ = CreateMaybeMessage< ::dapi::commands::ToggleCharacterSheet >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.toggleCharacterSheet)
  return command_.togglecharactersheet_;
}

// .dapi.commands.IncreaseStat increaseStat = 13;
inline bool Command::has_increasestat() const {
  return command_case() == kIncreaseStat;
}
inline void Command::set_has_increasestat() {
  _oneof_case_[0] = kIncreaseStat;
}
inline void Command::clear_increasestat() {
  if (has_increasestat()) {
    delete command_.increasestat_;
    clear_has_command();
  }
}
inline const ::dapi::commands::IncreaseStat& Command::_internal_increasestat() const {
  return *command_.increasestat_;
}
inline ::dapi::commands::IncreaseStat* Command::release_increasestat() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.increaseStat)
  if (has_increasestat()) {
    clear_has_command();
      ::dapi::commands::IncreaseStat* temp = command_.increasestat_;
    command_.increasestat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::IncreaseStat& Command::increasestat() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.increaseStat)
  return has_increasestat()
      ? *command_.increasestat_
      : *reinterpret_cast< ::dapi::commands::IncreaseStat*>(&::dapi::commands::_IncreaseStat_default_instance_);
}
inline ::dapi::commands::IncreaseStat* Command::mutable_increasestat() {
  if (!has_increasestat()) {
    clear_command();
    set_has_increasestat();
    command_.increasestat_ = CreateMaybeMessage< ::dapi::commands::IncreaseStat >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.increaseStat)
  return command_.increasestat_;
}

// .dapi.commands.GetItem getItem = 14;
inline bool Command::has_getitem() const {
  return command_case() == kGetItem;
}
inline void Command::set_has_getitem() {
  _oneof_case_[0] = kGetItem;
}
inline void Command::clear_getitem() {
  if (has_getitem()) {
    delete command_.getitem_;
    clear_has_command();
  }
}
inline const ::dapi::commands::GetItem& Command::_internal_getitem() const {
  return *command_.getitem_;
}
inline ::dapi::commands::GetItem* Command::release_getitem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.getItem)
  if (has_getitem()) {
    clear_has_command();
      ::dapi::commands::GetItem* temp = command_.getitem_;
    command_.getitem_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::GetItem& Command::getitem() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.getItem)
  return has_getitem()
      ? *command_.getitem_
      : *reinterpret_cast< ::dapi::commands::GetItem*>(&::dapi::commands::_GetItem_default_instance_);
}
inline ::dapi::commands::GetItem* Command::mutable_getitem() {
  if (!has_getitem()) {
    clear_command();
    set_has_getitem();
    command_.getitem_ = CreateMaybeMessage< ::dapi::commands::GetItem >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.getItem)
  return command_.getitem_;
}

// .dapi.commands.SetSpell setSpell = 15;
inline bool Command::has_setspell() const {
  return command_case() == kSetSpell;
}
inline void Command::set_has_setspell() {
  _oneof_case_[0] = kSetSpell;
}
inline void Command::clear_setspell() {
  if (has_setspell()) {
    delete command_.setspell_;
    clear_has_command();
  }
}
inline const ::dapi::commands::SetSpell& Command::_internal_setspell() const {
  return *command_.setspell_;
}
inline ::dapi::commands::SetSpell* Command::release_setspell() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.setSpell)
  if (has_setspell()) {
    clear_has_command();
      ::dapi::commands::SetSpell* temp = command_.setspell_;
    command_.setspell_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::SetSpell& Command::setspell() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.setSpell)
  return has_setspell()
      ? *command_.setspell_
      : *reinterpret_cast< ::dapi::commands::SetSpell*>(&::dapi::commands::_SetSpell_default_instance_);
}
inline ::dapi::commands::SetSpell* Command::mutable_setspell() {
  if (!has_setspell()) {
    clear_command();
    set_has_setspell();
    command_.setspell_ = CreateMaybeMessage< ::dapi::commands::SetSpell >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.setSpell)
  return command_.setspell_;
}

// .dapi.commands.CastMonster castMonster = 16;
inline bool Command::has_castmonster() const {
  return command_case() == kCastMonster;
}
inline void Command::set_has_castmonster() {
  _oneof_case_[0] = kCastMonster;
}
inline void Command::clear_castmonster() {
  if (has_castmonster()) {
    delete command_.castmonster_;
    clear_has_command();
  }
}
inline const ::dapi::commands::CastMonster& Command::_internal_castmonster() const {
  return *command_.castmonster_;
}
inline ::dapi::commands::CastMonster* Command::release_castmonster() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.castMonster)
  if (has_castmonster()) {
    clear_has_command();
      ::dapi::commands::CastMonster* temp = command_.castmonster_;
    command_.castmonster_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::CastMonster& Command::castmonster() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.castMonster)
  return has_castmonster()
      ? *command_.castmonster_
      : *reinterpret_cast< ::dapi::commands::CastMonster*>(&::dapi::commands::_CastMonster_default_instance_);
}
inline ::dapi::commands::CastMonster* Command::mutable_castmonster() {
  if (!has_castmonster()) {
    clear_command();
    set_has_castmonster();
    command_.castmonster_ = CreateMaybeMessage< ::dapi::commands::CastMonster >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.castMonster)
  return command_.castmonster_;
}

// .dapi.commands.CastXY castXY = 17;
inline bool Command::has_castxy() const {
  return command_case() == kCastXY;
}
inline void Command::set_has_castxy() {
  _oneof_case_[0] = kCastXY;
}
inline void Command::clear_castxy() {
  if (has_castxy()) {
    delete command_.castxy_;
    clear_has_command();
  }
}
inline const ::dapi::commands::CastXY& Command::_internal_castxy() const {
  return *command_.castxy_;
}
inline ::dapi::commands::CastXY* Command::release_castxy() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.castXY)
  if (has_castxy()) {
    clear_has_command();
      ::dapi::commands::CastXY* temp = command_.castxy_;
    command_.castxy_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::CastXY& Command::castxy() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.castXY)
  return has_castxy()
      ? *command_.castxy_
      : *reinterpret_cast< ::dapi::commands::CastXY*>(&::dapi::commands::_CastXY_default_instance_);
}
inline ::dapi::commands::CastXY* Command::mutable_castxy() {
  if (!has_castxy()) {
    clear_command();
    set_has_castxy();
    command_.castxy_ = CreateMaybeMessage< ::dapi::commands::CastXY >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.castXY)
  return command_.castxy_;
}

// .dapi.commands.ToggleInventory toggleInventory = 18;
inline bool Command::has_toggleinventory() const {
  return command_case() == kToggleInventory;
}
inline void Command::set_has_toggleinventory() {
  _oneof_case_[0] = kToggleInventory;
}
inline void Command::clear_toggleinventory() {
  if (has_toggleinventory()) {
    delete command_.toggleinventory_;
    clear_has_command();
  }
}
inline const ::dapi::commands::ToggleInventory& Command::_internal_toggleinventory() const {
  return *command_.toggleinventory_;
}
inline ::dapi::commands::ToggleInventory* Command::release_toggleinventory() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.toggleInventory)
  if (has_toggleinventory()) {
    clear_has_command();
      ::dapi::commands::ToggleInventory* temp = command_.toggleinventory_;
    command_.toggleinventory_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::ToggleInventory& Command::toggleinventory() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.toggleInventory)
  return has_toggleinventory()
      ? *command_.toggleinventory_
      : *reinterpret_cast< ::dapi::commands::ToggleInventory*>(&::dapi::commands::_ToggleInventory_default_instance_);
}
inline ::dapi::commands::ToggleInventory* Command::mutable_toggleinventory() {
  if (!has_toggleinventory()) {
    clear_command();
    set_has_toggleinventory();
    command_.toggleinventory_ = CreateMaybeMessage< ::dapi::commands::ToggleInventory >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.toggleInventory)
  return command_.toggleinventory_;
}

// .dapi.commands.PutInCursor putInCursor = 19;
inline bool Command::has_putincursor() const {
  return command_case() == kPutInCursor;
}
inline void Command::set_has_putincursor() {
  _oneof_case_[0] = kPutInCursor;
}
inline void Command::clear_putincursor() {
  if (has_putincursor()) {
    delete command_.putincursor_;
    clear_has_command();
  }
}
inline const ::dapi::commands::PutInCursor& Command::_internal_putincursor() const {
  return *command_.putincursor_;
}
inline ::dapi::commands::PutInCursor* Command::release_putincursor() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.putInCursor)
  if (has_putincursor()) {
    clear_has_command();
      ::dapi::commands::PutInCursor* temp = command_.putincursor_;
    command_.putincursor_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::PutInCursor& Command::putincursor() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.putInCursor)
  return has_putincursor()
      ? *command_.putincursor_
      : *reinterpret_cast< ::dapi::commands::PutInCursor*>(&::dapi::commands::_PutInCursor_default_instance_);
}
inline ::dapi::commands::PutInCursor* Command::mutable_putincursor() {
  if (!has_putincursor()) {
    clear_command();
    set_has_putincursor();
    command_.putincursor_ = CreateMaybeMessage< ::dapi::commands::PutInCursor >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.putInCursor)
  return command_.putincursor_;
}

// .dapi.commands.PutCursorItem putCursorItem = 20;
inline bool Command::has_putcursoritem() const {
  return command_case() == kPutCursorItem;
}
inline void Command::set_has_putcursoritem() {
  _oneof_case_[0] = kPutCursorItem;
}
inline void Command::clear_putcursoritem() {
  if (has_putcursoritem()) {
    delete command_.putcursoritem_;
    clear_has_command();
  }
}
inline const ::dapi::commands::PutCursorItem& Command::_internal_putcursoritem() const {
  return *command_.putcursoritem_;
}
inline ::dapi::commands::PutCursorItem* Command::release_putcursoritem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.putCursorItem)
  if (has_putcursoritem()) {
    clear_has_command();
      ::dapi::commands::PutCursorItem* temp = command_.putcursoritem_;
    command_.putcursoritem_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::PutCursorItem& Command::putcursoritem() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.putCursorItem)
  return has_putcursoritem()
      ? *command_.putcursoritem_
      : *reinterpret_cast< ::dapi::commands::PutCursorItem*>(&::dapi::commands::_PutCursorItem_default_instance_);
}
inline ::dapi::commands::PutCursorItem* Command::mutable_putcursoritem() {
  if (!has_putcursoritem()) {
    clear_command();
    set_has_putcursoritem();
    command_.putcursoritem_ = CreateMaybeMessage< ::dapi::commands::PutCursorItem >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.putCursorItem)
  return command_.putcursoritem_;
}

// .dapi.commands.DropCursorItem dropCursorItem = 21;
inline bool Command::has_dropcursoritem() const {
  return command_case() == kDropCursorItem;
}
inline void Command::set_has_dropcursoritem() {
  _oneof_case_[0] = kDropCursorItem;
}
inline void Command::clear_dropcursoritem() {
  if (has_dropcursoritem()) {
    delete command_.dropcursoritem_;
    clear_has_command();
  }
}
inline const ::dapi::commands::DropCursorItem& Command::_internal_dropcursoritem() const {
  return *command_.dropcursoritem_;
}
inline ::dapi::commands::DropCursorItem* Command::release_dropcursoritem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.dropCursorItem)
  if (has_dropcursoritem()) {
    clear_has_command();
      ::dapi::commands::DropCursorItem* temp = command_.dropcursoritem_;
    command_.dropcursoritem_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::DropCursorItem& Command::dropcursoritem() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.dropCursorItem)
  return has_dropcursoritem()
      ? *command_.dropcursoritem_
      : *reinterpret_cast< ::dapi::commands::DropCursorItem*>(&::dapi::commands::_DropCursorItem_default_instance_);
}
inline ::dapi::commands::DropCursorItem* Command::mutable_dropcursoritem() {
  if (!has_dropcursoritem()) {
    clear_command();
    set_has_dropcursoritem();
    command_.dropcursoritem_ = CreateMaybeMessage< ::dapi::commands::DropCursorItem >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.dropCursorItem)
  return command_.dropcursoritem_;
}

// .dapi.commands.UseItem useItem = 22;
inline bool Command::has_useitem() const {
  return command_case() == kUseItem;
}
inline void Command::set_has_useitem() {
  _oneof_case_[0] = kUseItem;
}
inline void Command::clear_useitem() {
  if (has_useitem()) {
    delete command_.useitem_;
    clear_has_command();
  }
}
inline const ::dapi::commands::UseItem& Command::_internal_useitem() const {
  return *command_.useitem_;
}
inline ::dapi::commands::UseItem* Command::release_useitem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.useItem)
  if (has_useitem()) {
    clear_has_command();
      ::dapi::commands::UseItem* temp = command_.useitem_;
    command_.useitem_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::UseItem& Command::useitem() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.useItem)
  return has_useitem()
      ? *command_.useitem_
      : *reinterpret_cast< ::dapi::commands::UseItem*>(&::dapi::commands::_UseItem_default_instance_);
}
inline ::dapi::commands::UseItem* Command::mutable_useitem() {
  if (!has_useitem()) {
    clear_command();
    set_has_useitem();
    command_.useitem_ = CreateMaybeMessage< ::dapi::commands::UseItem >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.useItem)
  return command_.useitem_;
}

// .dapi.commands.IdentifyStoreItem identifyStoreItem = 23;
inline bool Command::has_identifystoreitem() const {
  return command_case() == kIdentifyStoreItem;
}
inline void Command::set_has_identifystoreitem() {
  _oneof_case_[0] = kIdentifyStoreItem;
}
inline void Command::clear_identifystoreitem() {
  if (has_identifystoreitem()) {
    delete command_.identifystoreitem_;
    clear_has_command();
  }
}
inline const ::dapi::commands::IdentifyStoreItem& Command::_internal_identifystoreitem() const {
  return *command_.identifystoreitem_;
}
inline ::dapi::commands::IdentifyStoreItem* Command::release_identifystoreitem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.identifyStoreItem)
  if (has_identifystoreitem()) {
    clear_has_command();
      ::dapi::commands::IdentifyStoreItem* temp = command_.identifystoreitem_;
    command_.identifystoreitem_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::IdentifyStoreItem& Command::identifystoreitem() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.identifyStoreItem)
  return has_identifystoreitem()
      ? *command_.identifystoreitem_
      : *reinterpret_cast< ::dapi::commands::IdentifyStoreItem*>(&::dapi::commands::_IdentifyStoreItem_default_instance_);
}
inline ::dapi::commands::IdentifyStoreItem* Command::mutable_identifystoreitem() {
  if (!has_identifystoreitem()) {
    clear_command();
    set_has_identifystoreitem();
    command_.identifystoreitem_ = CreateMaybeMessage< ::dapi::commands::IdentifyStoreItem >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.identifyStoreItem)
  return command_.identifystoreitem_;
}

// .dapi.commands.CancelQText cancelQText = 24;
inline bool Command::has_cancelqtext() const {
  return command_case() == kCancelQText;
}
inline void Command::set_has_cancelqtext() {
  _oneof_case_[0] = kCancelQText;
}
inline void Command::clear_cancelqtext() {
  if (has_cancelqtext()) {
    delete command_.cancelqtext_;
    clear_has_command();
  }
}
inline const ::dapi::commands::CancelQText& Command::_internal_cancelqtext() const {
  return *command_.cancelqtext_;
}
inline ::dapi::commands::CancelQText* Command::release_cancelqtext() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.cancelQText)
  if (has_cancelqtext()) {
    clear_has_command();
      ::dapi::commands::CancelQText* temp = command_.cancelqtext_;
    command_.cancelqtext_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::CancelQText& Command::cancelqtext() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.cancelQText)
  return has_cancelqtext()
      ? *command_.cancelqtext_
      : *reinterpret_cast< ::dapi::commands::CancelQText*>(&::dapi::commands::_CancelQText_default_instance_);
}
inline ::dapi::commands::CancelQText* Command::mutable_cancelqtext() {
  if (!has_cancelqtext()) {
    clear_command();
    set_has_cancelqtext();
    command_.cancelqtext_ = CreateMaybeMessage< ::dapi::commands::CancelQText >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.cancelQText)
  return command_.cancelqtext_;
}

// .dapi.commands.SetFPS setFPS = 25;
inline bool Command::has_setfps() const {
  return command_case() == kSetFPS;
}
inline void Command::set_has_setfps() {
  _oneof_case_[0] = kSetFPS;
}
inline void Command::clear_setfps() {
  if (has_setfps()) {
    delete command_.setfps_;
    clear_has_command();
  }
}
inline const ::dapi::commands::SetFPS& Command::_internal_setfps() const {
  return *command_.setfps_;
}
inline ::dapi::commands::SetFPS* Command::release_setfps() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.setFPS)
  if (has_setfps()) {
    clear_has_command();
      ::dapi::commands::SetFPS* temp = command_.setfps_;
    command_.setfps_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::SetFPS& Command::setfps() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.setFPS)
  return has_setfps()
      ? *command_.setfps_
      : *reinterpret_cast< ::dapi::commands::SetFPS*>(&::dapi::commands::_SetFPS_default_instance_);
}
inline ::dapi::commands::SetFPS* Command::mutable_setfps() {
  if (!has_setfps()) {
    clear_command();
    set_has_setfps();
    command_.setfps_ = CreateMaybeMessage< ::dapi::commands::SetFPS >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.setFPS)
  return command_.setfps_;
}

// .dapi.commands.DisarmTrap disarmTrap = 26;
inline bool Command::has_disarmtrap() const {
  return command_case() == kDisarmTrap;
}
inline void Command::set_has_disarmtrap() {
  _oneof_case_[0] = kDisarmTrap;
}
inline void Command::clear_disarmtrap() {
  if (has_disarmtrap()) {
    delete command_.disarmtrap_;
    clear_has_command();
  }
}
inline const ::dapi::commands::DisarmTrap& Command::_internal_disarmtrap() const {
  return *command_.disarmtrap_;
}
inline ::dapi::commands::DisarmTrap* Command::release_disarmtrap() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.disarmTrap)
  if (has_disarmtrap()) {
    clear_has_command();
      ::dapi::commands::DisarmTrap* temp = command_.disarmtrap_;
    command_.disarmtrap_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::DisarmTrap& Command::disarmtrap() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.disarmTrap)
  return has_disarmtrap()
      ? *command_.disarmtrap_
      : *reinterpret_cast< ::dapi::commands::DisarmTrap*>(&::dapi::commands::_DisarmTrap_default_instance_);
}
inline ::dapi::commands::DisarmTrap* Command::mutable_disarmtrap() {
  if (!has_disarmtrap()) {
    clear_command();
    set_has_disarmtrap();
    command_.disarmtrap_ = CreateMaybeMessage< ::dapi::commands::DisarmTrap >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.disarmTrap)
  return command_.disarmtrap_;
}

// .dapi.commands.SkillRepair skillRepair = 27;
inline bool Command::has_skillrepair() const {
  return command_case() == kSkillRepair;
}
inline void Command::set_has_skillrepair() {
  _oneof_case_[0] = kSkillRepair;
}
inline void Command::clear_skillrepair() {
  if (has_skillrepair()) {
    delete command_.skillrepair_;
    clear_has_command();
  }
}
inline const ::dapi::commands::SkillRepair& Command::_internal_skillrepair() const {
  return *command_.skillrepair_;
}
inline ::dapi::commands::SkillRepair* Command::release_skillrepair() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.skillRepair)
  if (has_skillrepair()) {
    clear_has_command();
      ::dapi::commands::SkillRepair* temp = command_.skillrepair_;
    command_.skillrepair_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::SkillRepair& Command::skillrepair() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.skillRepair)
  return has_skillrepair()
      ? *command_.skillrepair_
      : *reinterpret_cast< ::dapi::commands::SkillRepair*>(&::dapi::commands::_SkillRepair_default_instance_);
}
inline ::dapi::commands::SkillRepair* Command::mutable_skillrepair() {
  if (!has_skillrepair()) {
    clear_command();
    set_has_skillrepair();
    command_.skillrepair_ = CreateMaybeMessage< ::dapi::commands::SkillRepair >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.skillRepair)
  return command_.skillrepair_;
}

// .dapi.commands.SkillRecharge skillRecharge = 28;
inline bool Command::has_skillrecharge() const {
  return command_case() == kSkillRecharge;
}
inline void Command::set_has_skillrecharge() {
  _oneof_case_[0] = kSkillRecharge;
}
inline void Command::clear_skillrecharge() {
  if (has_skillrecharge()) {
    delete command_.skillrecharge_;
    clear_has_command();
  }
}
inline const ::dapi::commands::SkillRecharge& Command::_internal_skillrecharge() const {
  return *command_.skillrecharge_;
}
inline ::dapi::commands::SkillRecharge* Command::release_skillrecharge() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.skillRecharge)
  if (has_skillrecharge()) {
    clear_has_command();
      ::dapi::commands::SkillRecharge* temp = command_.skillrecharge_;
    command_.skillrecharge_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::SkillRecharge& Command::skillrecharge() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.skillRecharge)
  return has_skillrecharge()
      ? *command_.skillrecharge_
      : *reinterpret_cast< ::dapi::commands::SkillRecharge*>(&::dapi::commands::_SkillRecharge_default_instance_);
}
inline ::dapi::commands::SkillRecharge* Command::mutable_skillrecharge() {
  if (!has_skillrecharge()) {
    clear_command();
    set_has_skillrecharge();
    command_.skillrecharge_ = CreateMaybeMessage< ::dapi::commands::SkillRecharge >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.skillRecharge)
  return command_.skillrecharge_;
}

// .dapi.commands.ToggleMenu toggleMenu = 29;
inline bool Command::has_togglemenu() const {
  return command_case() == kToggleMenu;
}
inline void Command::set_has_togglemenu() {
  _oneof_case_[0] = kToggleMenu;
}
inline void Command::clear_togglemenu() {
  if (has_togglemenu()) {
    delete command_.togglemenu_;
    clear_has_command();
  }
}
inline const ::dapi::commands::ToggleMenu& Command::_internal_togglemenu() const {
  return *command_.togglemenu_;
}
inline ::dapi::commands::ToggleMenu* Command::release_togglemenu() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.toggleMenu)
  if (has_togglemenu()) {
    clear_has_command();
      ::dapi::commands::ToggleMenu* temp = command_.togglemenu_;
    command_.togglemenu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::ToggleMenu& Command::togglemenu() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.toggleMenu)
  return has_togglemenu()
      ? *command_.togglemenu_
      : *reinterpret_cast< ::dapi::commands::ToggleMenu*>(&::dapi::commands::_ToggleMenu_default_instance_);
}
inline ::dapi::commands::ToggleMenu* Command::mutable_togglemenu() {
  if (!has_togglemenu()) {
    clear_command();
    set_has_togglemenu();
    command_.togglemenu_ = CreateMaybeMessage< ::dapi::commands::ToggleMenu >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.toggleMenu)
  return command_.togglemenu_;
}

// .dapi.commands.SaveGame saveGame = 30;
inline bool Command::has_savegame() const {
  return command_case() == kSaveGame;
}
inline void Command::set_has_savegame() {
  _oneof_case_[0] = kSaveGame;
}
inline void Command::clear_savegame() {
  if (has_savegame()) {
    delete command_.savegame_;
    clear_has_command();
  }
}
inline const ::dapi::commands::SaveGame& Command::_internal_savegame() const {
  return *command_.savegame_;
}
inline ::dapi::commands::SaveGame* Command::release_savegame() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.saveGame)
  if (has_savegame()) {
    clear_has_command();
      ::dapi::commands::SaveGame* temp = command_.savegame_;
    command_.savegame_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::SaveGame& Command::savegame() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.saveGame)
  return has_savegame()
      ? *command_.savegame_
      : *reinterpret_cast< ::dapi::commands::SaveGame*>(&::dapi::commands::_SaveGame_default_instance_);
}
inline ::dapi::commands::SaveGame* Command::mutable_savegame() {
  if (!has_savegame()) {
    clear_command();
    set_has_savegame();
    command_.savegame_ = CreateMaybeMessage< ::dapi::commands::SaveGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.saveGame)
  return command_.savegame_;
}

// .dapi.commands.Quit quit = 31;
inline bool Command::has_quit() const {
  return command_case() == kQuit;
}
inline void Command::set_has_quit() {
  _oneof_case_[0] = kQuit;
}
inline void Command::clear_quit() {
  if (has_quit()) {
    delete command_.quit_;
    clear_has_command();
  }
}
inline const ::dapi::commands::Quit& Command::_internal_quit() const {
  return *command_.quit_;
}
inline ::dapi::commands::Quit* Command::release_quit() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.quit)
  if (has_quit()) {
    clear_has_command();
      ::dapi::commands::Quit* temp = command_.quit_;
    command_.quit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::Quit& Command::quit() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.quit)
  return has_quit()
      ? *command_.quit_
      : *reinterpret_cast< ::dapi::commands::Quit*>(&::dapi::commands::_Quit_default_instance_);
}
inline ::dapi::commands::Quit* Command::mutable_quit() {
  if (!has_quit()) {
    clear_command();
    set_has_quit();
    command_.quit_ = CreateMaybeMessage< ::dapi::commands::Quit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.quit)
  return command_.quit_;
}

// .dapi.commands.ClearCursor clearCursor = 32;
inline bool Command::has_clearcursor() const {
  return command_case() == kClearCursor;
}
inline void Command::set_has_clearcursor() {
  _oneof_case_[0] = kClearCursor;
}
inline void Command::clear_clearcursor() {
  if (has_clearcursor()) {
    delete command_.clearcursor_;
    clear_has_command();
  }
}
inline const ::dapi::commands::ClearCursor& Command::_internal_clearcursor() const {
  return *command_.clearcursor_;
}
inline ::dapi::commands::ClearCursor* Command::release_clearcursor() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.clearCursor)
  if (has_clearcursor()) {
    clear_has_command();
      ::dapi::commands::ClearCursor* temp = command_.clearcursor_;
    command_.clearcursor_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::ClearCursor& Command::clearcursor() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.clearCursor)
  return has_clearcursor()
      ? *command_.clearcursor_
      : *reinterpret_cast< ::dapi::commands::ClearCursor*>(&::dapi::commands::_ClearCursor_default_instance_);
}
inline ::dapi::commands::ClearCursor* Command::mutable_clearcursor() {
  if (!has_clearcursor()) {
    clear_command();
    set_has_clearcursor();
    command_.clearcursor_ = CreateMaybeMessage< ::dapi::commands::ClearCursor >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.clearCursor)
  return command_.clearcursor_;
}

// .dapi.commands.IdentifyItem identifyItem = 33;
inline bool Command::has_identifyitem() const {
  return command_case() == kIdentifyItem;
}
inline void Command::set_has_identifyitem() {
  _oneof_case_[0] = kIdentifyItem;
}
inline void Command::clear_identifyitem() {
  if (has_identifyitem()) {
    delete command_.identifyitem_;
    clear_has_command();
  }
}
inline const ::dapi::commands::IdentifyItem& Command::_internal_identifyitem() const {
  return *command_.identifyitem_;
}
inline ::dapi::commands::IdentifyItem* Command::release_identifyitem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.identifyItem)
  if (has_identifyitem()) {
    clear_has_command();
      ::dapi::commands::IdentifyItem* temp = command_.identifyitem_;
    command_.identifyitem_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::IdentifyItem& Command::identifyitem() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.identifyItem)
  return has_identifyitem()
      ? *command_.identifyitem_
      : *reinterpret_cast< ::dapi::commands::IdentifyItem*>(&::dapi::commands::_IdentifyItem_default_instance_);
}
inline ::dapi::commands::IdentifyItem* Command::mutable_identifyitem() {
  if (!has_identifyitem()) {
    clear_command();
    set_has_identifyitem();
    command_.identifyitem_ = CreateMaybeMessage< ::dapi::commands::IdentifyItem >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.identifyItem)
  return command_.identifyitem_;
}

// .dapi.commands.SendChat sendChat = 34;
inline bool Command::has_sendchat() const {
  return command_case() == kSendChat;
}
inline void Command::set_has_sendchat() {
  _oneof_case_[0] = kSendChat;
}
inline void Command::clear_sendchat() {
  if (has_sendchat()) {
    delete command_.sendchat_;
    clear_has_command();
  }
}
inline const ::dapi::commands::SendChat& Command::_internal_sendchat() const {
  return *command_.sendchat_;
}
inline ::dapi::commands::SendChat* Command::release_sendchat() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.sendChat)
  if (has_sendchat()) {
    clear_has_command();
      ::dapi::commands::SendChat* temp = command_.sendchat_;
    command_.sendchat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dapi::commands::SendChat& Command::sendchat() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.sendChat)
  return has_sendchat()
      ? *command_.sendchat_
      : *reinterpret_cast< ::dapi::commands::SendChat*>(&::dapi::commands::_SendChat_default_instance_);
}
inline ::dapi::commands::SendChat* Command::mutable_sendchat() {
  if (!has_sendchat()) {
    clear_command();
    set_has_sendchat();
    command_.sendchat_ = CreateMaybeMessage< ::dapi::commands::SendChat >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.sendChat)
  return command_.sendchat_;
}

inline bool Command::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void Command::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline Command::CommandCase Command::command_case() const {
  return Command::CommandCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace commands
}  // namespace dapi

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_command_2eproto
